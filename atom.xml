<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ikaros の小屋</title>
  
  <subtitle>Keep You Sane</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.ikaroskun.xyz/"/>
  <updated>2020-01-29T14:23:48.816Z</updated>
  <id>https://blog.ikaroskun.xyz/</id>
  
  <author>
    <name>Ikaros Kun</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python 数据类 dataclasses 实践</title>
    <link href="https://blog.ikaroskun.xyz/2019/11/23/lan-python-dataclassess/"/>
    <id>https://blog.ikaroskun.xyz/2019/11/23/lan-python-dataclassess/</id>
    <published>2019-11-23T13:37:40.000Z</published>
    <updated>2020-01-29T14:23:48.816Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>从 <code>Python3.7</code> 版本开始，引入了一个新的模块 <code>dataclasses</code>，该模块主要提供了一种数据类的数据类的实现方式。基于 <a href="https://www.python.org/dev/peps/pep-0557/" target="_blank" rel="noopener">PEP-557</a>实现。 所谓数据类，类似 <code>Java</code> 语言中的 <code>Bean</code>。通过一个容器类(class)，继而使用对象的属性访问数据。</p><p>如果你使用过标准库中的 <code>collections.namedtuple</code>, 或者 <code>typing.NamedTuple</code>，<code>dataclasses</code>是与这两者类似的。</p><p>通过 <code>dataclasses</code> 我们可以更加方便的去定义一个数据类。并且可以通过原生的方式进行类型检查。</p><p>一个基础例子:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InventoryItem</span>:</span></span><br><span class="line">    <span class="string">'''Class for keeping track of an item in inventory.'''</span></span><br><span class="line">    name: str</span><br><span class="line">    unit_price: float</span><br><span class="line">    quantity_on_hand: int = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total_cost</span><span class="params">(self)</span> -> float:</span></span><br><span class="line">        <span class="keyword">return</span> self.unit_price * self.quantity_on_hand</span><br></pre></td></tr></tbody></table></figure></div><h1 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h1><p><code>dataclasses</code> 提供一个模块级的装饰器 <code>dataclass</code> 用来将类转化为数据类。该装饰器的原型定义如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@dataclasses.dataclass(*, init=True, repr=True, eq=True, order=False, unsafe_hash=False, frozen=False)</span></span><br></pre></td></tr></tbody></table></figure></div><p>提供的默认参数用来控制是否生成相应的魔术方法。如 <code>repr</code> 为 <code>True</code> 时，将会自动生成 <code>__repr__</code> 方法。</p><p>我们定义一个简单的数据类，用以实现一个使用对象的属性存储实体 <code>Person</code> 数据：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@dataclasses.dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    name: str</span><br><span class="line">    age: int = <span class="number">20</span></span><br></pre></td></tr></tbody></table></figure></div><p>该类中定义了两个属性 <code>name</code> 和 <code>age</code>。分别表示名称和年龄，并且说明 <code>name</code> 属性是一个字符串，<code>age</code> 属性是一个数字(注意： 因为 <code>Python</code> 编译器不会对此处的类型进行强制检查)，并为 <code>age</code> 属性设置了默认值 <code>20</code>。</p><p>我们可以这样去使用：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [1]: person = Person(<span class="string">'ikaros'</span>, 24)</span><br><span class="line"></span><br><span class="line">In [2]: person.name</span><br><span class="line">Out[2]: <span class="string">'ikaros'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 因为默认情况下 `repr` 是自动生成的，所以我们得到 `person` 的字符串表示。</span></span><br><span class="line">In [3]: person</span><br><span class="line">Out[3]: Person(name=<span class="string">'ikaros'</span>, age=24)</span><br></pre></td></tr></tbody></table></figure></div><p>通过使用 <code>field</code> 我们可以对参数做更多的定制化，如：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@dataclasses.dataclass</span><br><span class="line">class Person:</span><br><span class="line">    name: str</span><br><span class="line">    age: int = dataclasses.field(default=20, repr=False)</span><br></pre></td></tr></tbody></table></figure></div><p>此处我们为 <code>age</code> 属性赋予了一个额外的 <code>repr</code> 为 <code>False</code> 的参数。该参数说明，在调用 <code>__repr__</code> 方法时，不展示 <code>age</code> 属性：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [4]: person</span><br><span class="line">Out[4]: Person(name=<span class="string">'ikaros'</span>)</span><br></pre></td></tr></tbody></table></figure></div><p>更多的 <code>field</code> 说明，可以查看 <a href="https://docs.python.org/zh-cn/3.7/library/dataclasses.html#dataclasses.field" target="_blank" rel="noopener">参考文档</a>。</p><h1 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h1><p>此处我们通过一个实际的例子展示 <code>dataclasses</code> 的用法.</p><p>现有一个数据实体内部的数据如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">json</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">    <span class="attr">"id"</span>: <span class="string">"20531316728"</span>,</span><br><span class="line">    <span class="attr">"about"</span>: <span class="string">"The Facebook Page celebrates how our friends inspire us, support us, and help us discover the world when we connect."</span>,</span><br><span class="line">    <span class="attr">"birthday"</span>: <span class="string">"02/04/2004"</span>,</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"Facebook"</span>,</span><br><span class="line">    <span class="attr">"username"</span>: <span class="string">"facebookapp"</span>,</span><br><span class="line">    <span class="attr">"fan_count"</span>: <span class="number">214643503</span>,</span><br><span class="line">    <span class="attr">"cover"</span>: {</span><br><span class="line">        <span class="attr">"cover_id"</span>: <span class="string">"10158913960541729"</span>,</span><br><span class="line">        <span class="attr">"offset_x"</span>: <span class="number">50</span>,</span><br><span class="line">        <span class="attr">"offset_y"</span>: <span class="number">50</span>,</span><br><span class="line">        <span class="attr">"source"</span>: <span class="string">"https://scontent.xx.fbcdn.net/v/t1.0-9/s720x720/73087560_10158913960546729_8876113648821469184_o.jpg?_nc_cat=1&_nc_ohc=bAJ1yh0abN4AQkSOGhMpytya2quC_uS0j0BF-XEVlRlgwTfzkL_F0fojQ&_nc_ht=scontent.xx&oh=2964a1a64b6b474e64b06bdb568684da&oe=5E454425"</span>,</span><br><span class="line">        <span class="attr">"id"</span>: <span class="string">"10158913960541729"</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>我们通过定义一个对应的数据类来表示该数据实体：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Page</span>:</span></span><br><span class="line">    id: str = <span class="literal">None</span></span><br><span class="line">    about: str = field(default=<span class="literal">None</span>, repr=<span class="literal">False</span>)</span><br><span class="line">    birthday: str = field(default=<span class="literal">None</span>, repr=<span class="literal">False</span>)</span><br><span class="line">    name: str = <span class="literal">None</span></span><br><span class="line">    username: str = <span class="literal">None</span></span><br><span class="line">    fan_count: int = field(default=<span class="literal">None</span>, repr=<span class="literal">False</span>)</span><br><span class="line">    cover: dict = field(default=<span class="literal">None</span>, repr=<span class="literal">False</span>)</span><br></pre></td></tr></tbody></table></figure></div><p>将数据传入到数据类中：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># data 为 上述的数据</span></span><br><span class="line">In [5]: p = Page(**data)</span><br></pre></td></tr></tbody></table></figure></div><p>对数据进行操作：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取数据</span></span><br><span class="line">In [6]: p.name</span><br><span class="line">Out[6]: <span class="string">'Facebook'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串展示</span></span><br><span class="line">In [7]: p</span><br><span class="line">Out[8]: Page(id=<span class="string">'20531316728'</span>, name=<span class="string">'Facebook'</span>, username=<span class="string">'facebookapp'</span>)</span><br><span class="line"></span><br><span class="line">In [9]: p.cover</span><br><span class="line">Out[9]: </span><br><span class="line">{<span class="string">'cover_id'</span>: <span class="string">'10158913960541729'</span>,</span><br><span class="line"> <span class="string">'offset_x'</span>: 50,</span><br><span class="line"> <span class="string">'offset_y'</span>: 50,</span><br><span class="line"> <span class="string">'source'</span>: <span class="string">'https://scontent.xx.fbcdn.net/v/t1.0-9/s720x720/73087560_10158913960546729_8876113648821469184_o.jpg?_nc_cat=1&_nc_ohc=bAJ1yh0abN4AQkSOGhMpytya2quC_uS0j0BF-XEVlRlgwTfzkL_F0fojQ&_nc_ht=scontent.xx&oh=2964a1a64b6b474e64b06bdb568684da&oe=5E454425'</span>,</span><br><span class="line"> <span class="string">'id'</span>: <span class="string">'10158913960541729'</span>}</span><br></pre></td></tr></tbody></table></figure></div><p>上述完整代码参见 <a href="https://github.com/MerleLiuKun/my-python/blob/master/sundries/dataclass/demo1.py" target="_blank" rel="noopener">demo1</a> </p><p>我们在上述的代码发现, 在调用 <code>p.cover</code> 属性时，返回的是一个字典，在正常的使用时，我们是想将 <code>cover</code> 属性也声明为一个数据类。则需要对上述的代码进行修改。</p><p>添加一个 <code>Cover</code> 的数据类实现：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cover</span>:</span></span><br><span class="line">    id: str = <span class="literal">None</span></span><br><span class="line">    cover_id: str = <span class="literal">None</span></span><br><span class="line">    offset_x: str = field(default=<span class="literal">None</span>, repr=<span class="literal">False</span>)</span><br><span class="line">    offset_y: str = field(default=<span class="literal">None</span>, repr=<span class="literal">False</span>)</span><br><span class="line">    source: str = field(default=<span class="literal">None</span>, repr=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Page</span>:</span></span><br><span class="line">    ...  <span class="comment"># 此处不再复制上方的属性</span></span><br><span class="line">    cover: Cover = field(default=<span class="literal">None</span>, repr=<span class="literal">False</span>)  <span class="comment"># 修改 `cover` 属性</span></span><br></pre></td></tr></tbody></table></figure></div><p>但是这时候，如果我们按照刚才的初始化方式，<code>cover</code> 属性不会被识别到。</p><p>我们可以通过添加一个额外的初始化的方法用来初始化到 <code>cover</code> 属性.</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dicts_to_dataclasses</span><span class="params">(instance)</span>:</span></span><br><span class="line">    <span class="string">"""将所有的数据类属性都转化到数据类中"""</span></span><br><span class="line">    cls = type(instance)</span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> fields(cls):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> is_dataclass(f.type):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        value = getattr(instance, f.name)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(value, dict):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        new_value = f.type(**value)</span><br><span class="line">        setattr(instance, f.name, new_value)</span><br></pre></td></tr></tbody></table></figure></div><p>并且修改上层数据类 <code>Page</code> 的代码，添加一个 <code>__post_init__</code> 方法， 该方法会被自动生成的 <code>__init__</code> 方法调用，进而将 <code>Cover</code> 数据类进行初始化。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Page</span>:</span></span><br><span class="line">    ...  <span class="comment"># 上方的属性</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__post_init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        dicts_to_dataclasses(self)</span><br></pre></td></tr></tbody></table></figure></div><p>上述完整代码参见 <a href="https://github.com/MerleLiuKun/my-python/blob/master/sundries/dataclass/demo2.py" target="_blank" rel="noopener">demo2</a></p><p>此时我们去初始化时，便可以将子数据类 <code>Cover</code> 也初始化了。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [10]: p.cover</span><br><span class="line">Out[10]: Cover(id=<span class="string">'10158913960541729'</span>, cover_id=<span class="string">'10158913960541729'</span>)</span><br></pre></td></tr></tbody></table></figure></div><p>此外，<code>dataclasses</code> 还提供了对数据类到字典的转化。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [11]: from dataclasses import asdict</span><br><span class="line">In [12]: asdict(p)</span><br><span class="line">Out[12]:</span><br><span class="line">{<span class="string">'id'</span>: <span class="string">'20531316728'</span>,</span><br><span class="line">....</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>我们可以对上边的代码进行整合一下。将通用的一些函数放到一个 <code>base</code> 基类中。</p><p>完整代码参见 <a href="https://github.com/MerleLiuKun/my-python/blob/master/sundries/dataclass/demo3.py" target="_blank" rel="noopener">demo3</a></p><h1 id="第三方增强库"><a href="#第三方增强库" class="headerlink" title="第三方增强库"></a>第三方增强库</h1><p>上边我们只是对含有嵌套字典的复杂数据进行了处理。事实上，生产中的数据的样式会更加复杂。我们根据需求自行对 <code>dicts_to_dataclasses</code> 函数进行升级处理，或者使用第三方库进行处理。</p><p>此处我们以第三方库 <code>dataclasses-json</code> 来给出一个示例，详细代码参见 <a href="https://github.com/MerleLiuKun/my-python/blob/master/sundries/dataclass/demo_with_dataclasses_json.py" target="_blank" rel="noopener">demo-with-dataclasses-json</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.kawabangga.com/posts/2959" target="_blank" rel="noopener">Python3.7 dataclass 介绍</a></li><li><a href="https://docs.python.org/zh-cn/3.7/library/dataclasses.html" target="_blank" rel="noopener">dataclasses—数据类(官方文档)</a></li><li><a href="https://github.com/lidatong/dataclasses-json" target="_blank" rel="noopener">dataclasses-json</a></li></ul></body></html>]]></content>
    
    <summary type="html">
    
      Python 数据类 dataclasses 实践
    
    </summary>
    
    
      <category term="Python" scheme="https://blog.ikaroskun.xyz/categories/Python/"/>
    
    
      <category term="python" scheme="https://blog.ikaroskun.xyz/tags/python/"/>
    
      <category term="dataclasses" scheme="https://blog.ikaroskun.xyz/tags/dataclasses/"/>
    
  </entry>
  
  <entry>
    <title>优化你的git-commit-message</title>
    <link href="https://blog.ikaroskun.xyz/2019/08/20/tool-git-message/"/>
    <id>https://blog.ikaroskun.xyz/2019/08/20/tool-git-message/</id>
    <published>2019-08-20T11:59:03.000Z</published>
    <updated>2020-01-29T14:23:48.816Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>无论是写公司的项目或者是自己的项目时，总要向仓库中提交代码。每个人提交代码时写的提交信息都不一样。有随意写各种 <code>modify</code>, <code>fix</code>等简单的，还有一些比较友好，会写上自己此次提交的简介。个人觉得第二种对代码review，或者查找bug引入点时会更有帮助。</p><p>简单做个比较如下：</p><p>一、</p><p><a href="https://i.loli.net/2020/01/20/765QTkLY3jlBHgF.png" data-fancybox="group" data-caption="formated.png" class="fancybox"><img alt="formated.png" title="formated.png" data-src="https://i.loli.net/2020/01/20/765QTkLY3jlBHgF.png" class="lazyload"></a></p><p>二、<br><a href="https://i.loli.net/2020/01/20/VrKt2EXGcwjyDhC.png" data-fancybox="group" data-caption="not_formated.png" class="fancybox"><img alt="not_formated.png" title="not_formated.png" data-src="https://i.loli.net/2020/01/20/VrKt2EXGcwjyDhC.png" class="lazyload"></a></p><p>对比之下第一种更加清晰明了。</p><h1 id="规范-Commit-message"><a href="#规范-Commit-message" class="headerlink" title="规范 Commit message"></a>规范 Commit message</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>基本上很多团队都有自己的相关规范说明，但是目前使用的比较广泛是 <a href="https://docs.google.com/document/d/1QrDFcIiPjSLDn3EL15IJygNPiHORgU1_OOAqWjiDU5Y/edit#heading=h.greljkmo14y0" target="_blank" rel="noopener">Angular 规范</a>, 基本样式如 上文第一张图所示。</p><p>使用依据规范的 <code>Commit message</code> 会有很多好处， 比如：</p><p>(1) 提供更多的信息，方便快速浏览。</p><p>基于规范的 <code>message</code> 可以直接信息中就包含此次提交的内容。也可以基于 <code>message</code>进行过滤</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sh</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> v0.3 HEAD --grep feat</span><br></pre></td></tr></tbody></table></figure></div><p>(2) 可以直接根据 <code>commit</code> 生成对应的 <code>Change Log</code>.</p><h2 id="Commit-message-格式"><a href="#Commit-message-格式" class="headerlink" title="Commit message 格式"></a>Commit message 格式</h2><p>每次提交 都需要包含三部分：Header，Body 和 Footer。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><type>(<scope>): <subject></subject></scope></type></span><br><span class="line">// 空一行</span><br><span class="line"></span><br><span class="line">// 空一行</span><br><span class="line"><footer><br></footer></span></pre></td></tr></tbody></table></figure></div><p>其中 <code>header</code>  是必须的，另外两个可以不写。</p><ul><li>标题行: 必填, 描述主要修改类型和内容</li><li>主题内容: 描述为什么修改, 做了什么样的修改, 以及开发的思路等等</li><li>页脚注释: 放 Breaking Changes 或 Closed Issues</li></ul><p>其中 标题包括三个字段：<code>type</code>（必需）、<code>scope</code>（可选）和 <code>subject</code>（必需）。</p><p>type 有以下一些常见类型：</p><ul><li>feat：新功能（feature）</li><li>fix：修补bug</li><li>docs：文档（documentation）</li><li>style： 格式（不影响代码运行的变动）</li><li>refactor：重构（即不是新增功能，也不是修改bug的代码变动）</li><li>test：增加测试</li><li>chore：构建过程或辅助工具的变动</li></ul><p>scope 说明此次变动的范围，一般视具体的项目而定。</p><p>subject 是此次提交的简要描述。</p><h1 id="工具-Commitizen"><a href="#工具-Commitizen" class="headerlink" title="工具 Commitizen"></a>工具 Commitizen</h1><p>如果我们每次手写以上的格式，必定是个痛苦的事情。所以可以使用 <a href="https://github.com/commitizen/cz-cli" target="_blank" rel="noopener">Commitizen</a><br>这个格式化工具进行撰写.</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>可以进行全局安装或者基于某项目安装。</p><p>全局安装如下：</p><p>需要在配置文件中指定 <code>Adapter</code></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sh</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install -g commitizen cz-conventional-changelog</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'{ "path": "cz-conventional-changelog" }'</span> > ~/.czrc</span><br></pre></td></tr></tbody></table></figure></div><p>当然可能你喜欢的格式与某个项目下要求的格式不一致。可以在某项目下进行配置。</p><p>项目内安装：<br>需要在项目目录下配置 <code>package.json</code>文件。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">npm install -D commitizen cz-conventional-changelog</span><br><span class="line"></span><br><span class="line"># 以下写入package.json.</span><br><span class="line">"script": {</span><br><span class="line">    ...,</span><br><span class="line">    "commit": "git-cz",</span><br><span class="line">},</span><br><span class="line"> "config": {</span><br><span class="line">    "commitizen": {</span><br><span class="line">      "path": "node_modules/cz-conventional-changelog"</span><br><span class="line">    }</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure></div><p>需要提交代码时，执行 <code>git cz -a</code></p><p>效果如下：</p><p><a href="https://i.loli.net/2020/01/20/aUMm2kZSbBpeVX7.png" data-fancybox="group" data-caption="commitizen.png" class="fancybox"><img alt="commitizen.png" title="commitizen.png" data-src="https://i.loli.net/2020/01/20/aUMm2kZSbBpeVX7.png" class="lazyload"></a></p><h2 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h2><p>如果需要自行配置相关的 <code>Adapter</code>, 可以使用 <a href="https://github.com/leonardoanalista/cz-customizable" target="_blank" rel="noopener">cz-customizable</a> 进行自定义。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sh</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i -g cz-customizable  <span class="comment"># 全局</span></span><br><span class="line">npm i -D cz-customizable  <span class="comment"># 项目级</span></span><br></pre></td></tr></tbody></table></figure></div><p>修改对应的配置：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sh</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全局 .czrc</span></span><br><span class="line">{ <span class="string">"path"</span>: <span class="string">"cz-customizable"</span> }</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目级 (package.json)</span></span><br><span class="line"><span class="string">"config"</span>: {</span><br><span class="line">    <span class="string">"commitizen"</span>: {</span><br><span class="line">        <span class="string">"path"</span>: <span class="string">"node_modules/cz-customizable"</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>推荐一下大佬的配置 <a href="https://gist.github.com/leohxj/7bc928f60bfa46a3856ddf7c0f91ab98" target="_blank" rel="noopener"> leohxj/.cz-config.js</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html" target="_blank" rel="noopener">Commit message 和 Change log 编写指南-阮一峰</a></li><li><a href="https://zhuanlan.zhihu.com/p/34223150" target="_blank" rel="noopener">优雅的提交你的 Git Commit Message-阿里南京技术专刊</a></li></ul></body></html>]]></content>
    
    <summary type="html">
    
      优化你的git-commit-message
    
    </summary>
    
    
      <category term="Git" scheme="https://blog.ikaroskun.xyz/categories/Git/"/>
    
    
      <category term="git" scheme="https://blog.ikaroskun.xyz/tags/git/"/>
    
      <category term="commitizen" scheme="https://blog.ikaroskun.xyz/tags/commitizen/"/>
    
  </entry>
  
  <entry>
    <title>MinIO对象存储服务介绍</title>
    <link href="https://blog.ikaroskun.xyz/2019/05/25/tool-minio-tutorial/"/>
    <id>https://blog.ikaroskun.xyz/2019/05/25/tool-minio-tutorial/</id>
    <published>2019-05-25T09:40:16.000Z</published>
    <updated>2020-01-29T14:23:48.816Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>来自官网的介绍:</p><p><a href="https://docs.min.io/cn/minio-quickstart-guide.html" target="_blank" rel="noopener">MinIO</a> 是一个基于 <code>Apache License v2.0</code> 开源协议的对象存储服务。它兼容亚马逊S3云存储服务接口，非常适合于存储大容量非结构化的数据，例如图片、视频、日志文件、备份数据和容器/虚拟机镜像等，而一个对象文件可以是任意大小，从几kb到最大5T不等。</p><p><code>MinIO</code> 是一个非常轻量的服务,可以很简单的和其他应用的结合，类似 NodeJS, Redis 或者 MySQL.</p><p>简单来说, 我们可以基于 <code>MinIO</code> 搭建一个类似亚马逊S3(腾讯云OSS)的存储服务。</p><a id="more"></a><h1 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h1><p>官网上给出的安装步骤十分详细和完整。这里只简单罗列一下。 以下使用 <code>Docker</code> 进行部署的.</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a href="https://docs.min.io/cn/minio-quickstart-guide.html" target="_blank" rel="noopener">官网详细安装说明</a></p><p>拉取镜像</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker pull minio/minio</span><br></pre></td></tr></tbody></table></figure></div><p>为了方便升级，迁移等操作, 我们将 <code>MinIO</code> 的数据放到宿主机上, 然后挂载到容器里。另外因为使用 <code>Docker</code> 部署, 所以需要自定义初始的账号信息. 基础的命令如下:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -p 9000:9000 --name minio-server \</span><br><span class="line">  -e <span class="string">"MINIO_ACCESS_KEY=Your Key"</span> \</span><br><span class="line">  -e <span class="string">"MINIO_SECRET_KEY=Your Secret"</span> \</span><br><span class="line">  -v /data/minio_data:/data \</span><br><span class="line">  -v /data/minio_config:/root/.minio \</span><br><span class="line">  -d minio/minio server /data</span><br></pre></td></tr></tbody></table></figure></div><blockquote><p>可以将命令写到脚本里, 方便修改和执行。</p></blockquote><p>此时, <code>MinIO</code> 服务已经起来了. 如果你是在本地搭建的, 可以使用你指定的账号信息访问 <a href="http://127.0.0.1:9000" target="_blank" rel="noopener">http://127.0.0.1:9000</a>. 如果可以访问, 即表明已经部署成功。</p><h2 id="Nginx配置"><a href="#Nginx配置" class="headerlink" title="Nginx配置"></a>Nginx配置</h2><p>如果我们想要搭建一个私有的存储服务，那么部署一定是在服务器上。我们可以使用 <code>Nginx</code> 配置一下代理.<br>官方也给了使用 <code>Nginx</code> 做代理的配置说明 <a href="https://docs.min.io/cn/setup-nginx-proxy-with-minio.html" target="_blank" rel="noopener">为MinIO Server设置Nginx代理</a> 。</p><p>简单列一下我的配置.</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">nginx</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight nginx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> minioServer {</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:9000</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment"># minio</span></span><br><span class="line"><span class="section">server</span> {</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  img.example.com;  <span class="comment"># your domain</span></span><br><span class="line">    <span class="attribute">return</span> <span class="number">301</span> https://<span class="variable">$host</span><span class="variable">$request_uri</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment"># https</span></span><br><span class="line"><span class="section">server</span> {</span><br><span class="line">    <span class="attribute">listen</span>        <span class="number">443</span>;</span><br><span class="line">    <span class="attribute">server_name</span>   img.example.com;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_certificate</span>      /path/to/chain.pem;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span>  /path/to/privkey.pem;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / {</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$http_host</span>;  <span class="comment"># 请求头转发</span></span><br><span class="line">        <span class="attribute">proxy_pass</span> http://minioServer;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>重启 <code>Nginx</code> 服务. 然后可以 访问 <a href="https://img.example.com" target="_blank" rel="noopener">https://img.example.com</a> 来验证配置状态。</p><h2 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h2><p><code>MinIO</code> 提供了更多的一些配置，比如 <code>TLS安全访问</code>, <code>状态通知</code>等, 可以依据官方文档进行相关的配置。</p><p>接下来, 就可以愉快的使用它了。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://github.com/minio/minio" target="_blank" rel="noopener">官方Github</a></li><li><a href="https://docs.min.io/" target="_blank" rel="noopener">官方文档</a></li></ul></body></html>]]></content>
    
    <summary type="html">
    
      MinIO对象存储服务介绍
    
    </summary>
    
    
      <category term="storage" scheme="https://blog.ikaroskun.xyz/categories/storage/"/>
    
      <category term="minio" scheme="https://blog.ikaroskun.xyz/categories/storage/minio/"/>
    
    
      <category term="storage" scheme="https://blog.ikaroskun.xyz/tags/storage/"/>
    
      <category term="minio" scheme="https://blog.ikaroskun.xyz/tags/minio/"/>
    
  </entry>
  
  <entry>
    <title>MySQL查询优化一</title>
    <link href="https://blog.ikaroskun.xyz/2019/05/14/sql-mysql-query-optimize-1/"/>
    <id>https://blog.ikaroskun.xyz/2019/05/14/sql-mysql-query-optimize-1/</id>
    <published>2019-05-14T11:38:02.000Z</published>
    <updated>2020-01-29T14:23:48.816Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id="建立索引的几大原则"><a href="#建立索引的几大原则" class="headerlink" title="建立索引的几大原则"></a>建立索引的几大原则</h1><h2 id="最左前缀匹配原则"><a href="#最左前缀匹配原则" class="headerlink" title="最左前缀匹配原则"></a>最左前缀匹配原则</h2><p>简单定义:<br>MySQL会一直向右匹配直到遇到范围查询 <code>(>,<,between,like)</code> 就停止匹配.</p><p>所以在针对查询条件进行创建索引时，要将范围级的条件放到索引字段的最后。以让 <code>MySQL</code> 使用索引。</p><h2 id="查询优化器"><a href="#查询优化器" class="headerlink" title="查询优化器"></a>查询优化器</h2><p>理论上来说 索引对顺序很敏感，但是MySQL的查询优化器会自动调整where子句的条件顺序以使用适合的索引。这属于编译器层次优化.<br>举例： 当 <code>where</code> 条件为 <code>a=1 AND b=2 AND c=3</code> 时, 对应建立的索引 <code>(a,b,c)</code> 列可以以任意顺序建立</p><h2 id="选择区分度高的列"><a href="#选择区分度高的列" class="headerlink" title="选择区分度高的列"></a>选择区分度高的列</h2><p>如果列的区分度很小，那么为这个列创建索引就不太合适了。比如 性别、某些状态字段之类的。</p><p>有个计算公式：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count(distinct col) / count(*)</span><br></pre></td></tr></tbody></table></figure></div><p>一般要求 <code>0.1</code> 以上 <a href="https://tech.meituan.com/2014/06/30/mysql-index.html" target="_blank" rel="noopener">参考此处</a></p><h2 id="索引列不参与计算"><a href="#索引列不参与计算" class="headerlink" title="索引列不参与计算"></a>索引列不参与计算</h2><p>当为某列数据加上索引之后, 不能将该列直接参与计算。因为索引源数据中存的都是字段值, 使用计算时需要将所有的字段进行计算之后才能比较。 这样的情况 可以先对条件进行计算，比较计算后的值。</p><h2 id="尽量扩展索引"><a href="#尽量扩展索引" class="headerlink" title="尽量扩展索引"></a>尽量扩展索引</h2><p>当表中已经存在索引，需要新增索引列时，优先考虑在原有的索引上进行增加。<br>如: 已存在索引 <code>(a)</code>, 需要增加联合索引 <code>(a,b)</code> 时， 可以直接在原索引上修改。</p><p>但如果需要添加的另外的与当前索引列无关的索引时，需要另外创建。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://tech.meituan.com/2014/06/30/mysql-index.html" target="_blank" rel="noopener">MySQL索引原理及慢查询优化</a></li><li><a href="https://book.douban.com/subject/24708143/" target="_blank" rel="noopener">MySQL技术内幕:InnoDB存储引擎(第2版)</a></li><li><a href="https://www.cnblogs.com/nixi8/p/4574709.html" target="_blank" rel="noopener">MySQL索引攻略</a></li></ul></body></html>]]></content>
    
    <summary type="html">
    
      MySQL查询优化一
    
    </summary>
    
    
      <category term="sql" scheme="https://blog.ikaroskun.xyz/categories/sql/"/>
    
      <category term="mysql" scheme="https://blog.ikaroskun.xyz/categories/sql/mysql/"/>
    
    
      <category term="mysql" scheme="https://blog.ikaroskun.xyz/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>令牌桶算法浅析</title>
    <link href="https://blog.ikaroskun.xyz/2019/04/09/alg-token-bucket/"/>
    <id>https://blog.ikaroskun.xyz/2019/04/09/alg-token-bucket/</id>
    <published>2019-04-09T09:01:40.000Z</published>
    <updated>2020-01-29T14:23:48.816Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>负责的项目中有一个爬虫调度项目。基础的模型就是利用平台提供的 <code>Token</code> 通过相关的数据 <code>API</code> 从平台获取数据。<br>对于每个 <code>Token</code> 均存在一个短时间内调用的上限。一旦超出限制，将在一段时间内不能进行继续获取。<br>之前对于这个限制的管理比较简单，当任务触发时，会直接发起数据获取请求。通过检查返回信息，判断是否超限，如果超限，设置一个等待时间之后进行重试。但发现这样没有最大化的利用到 <code>Token</code>. 因为发起请求本身就是对 <code>Token</code> 的一种消耗。<br>最近跟组长进行讨论相关细节时，他提到可以利用 <code>Nginx</code> 的流量限制来进行改进。研究之后发现<code>令牌桶算法</code>很合适这个需求。</p><h2 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h2><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>令牌桶(<code>token bucket</code>)算法是 <code>nginx</code> 进行流量限制的一种常用算法。常用于控制发送到网络上的数据的数量，并允许突发数据的发送。</p><h4 id="基础流程图"><a href="#基础流程图" class="headerlink" title="基础流程图"></a>基础流程图</h4><p>当数据请求来临时，算法通过检查当前桶的令牌量，如果令牌量足以支持消耗，即会进行接下来的处理。<br>如果令牌不足，则会将请求抛弃(获取缓存，看相关需求)</p><p><a href="https://i.loli.net/2020/01/26/lE69Vhb3L72XyY5.png" data-fancybox="group" data-caption="token-bucket.png" class="fancybox"><img alt="token-bucket.png" title="token-bucket.png" data-src="https://i.loli.net/2020/01/26/lE69Vhb3L72XyY5.png" class="lazyload"></a></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>在当前的需求中，对每一个 <code>Token</code> 实例添加一个容量桶。存储当前的可调用次数。当有 <code>worker</code> 发起请求时，先检查当前的可调用余量。<br>如果余量足够，则返回可调用状态，并设置当前的处理时间。当请求完毕时，对桶进行主动更新。如果当前余量不足以进行请求，则可以返回需要等待的时间，或者执行切换 <code>Token</code> 实例等操作。</p><h4 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TokenBucket</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, rate=<span class="number">0.1</span>, capacity=<span class="number">100</span>)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        此 为 单例</span></span><br><span class="line"><span class="string">        初始化时 应设置 当前的容量为 总容量</span></span><br><span class="line"><span class="string">        :param rate: 速率 秒为单位</span></span><br><span class="line"><span class="string">        :param capacity: 总容量</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self._rate = rate</span><br><span class="line">        self._capacity = capacity</span><br><span class="line">        self.current_amount = capacity</span><br><span class="line">        self._last_consumed_at = int(time.time())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">consume</span><span class="params">(self, need_amount=<span class="number">1</span>)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        进行消费</span></span><br><span class="line"><span class="string">        :param need_amount:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        increments = (int(time.time()) - self._last_consumed_at) * self._rate</span><br><span class="line">        self.current_amount = min(</span><br><span class="line">            self.current_amount + increments, self._capacity</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">if</span> need_amount > self.current_amount:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        self.current_amount = self.current_amount - need_amount</span><br><span class="line">        self._last_consumed_at = int(time.time())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self, amount)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        存在一个更新操作，用于 Token 余量状态主动返回</span></span><br><span class="line"><span class="string">        并重新计算 最后消费时间</span></span><br><span class="line"><span class="string">        :param amount: 主动发送的数量</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.current_amount = min(amount, self._capacity)</span><br><span class="line">        self._last_consumed_at = int(time.time())</span><br></pre></td></tr></tbody></table></figure></div><p>源码可访问 <a href="https://github.com/MerleLiuKun/my-python/blob/master/crawler/distributor/token_bucket.py" target="_blank" rel="noopener">code</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://en.wikipedia.org/wiki/Token_bucket" target="_blank" rel="noopener">token bucket</a></li><li><a href="https://baike.baidu.com/item/%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">令牌桶算法</a></li><li><a href="https://juejin.im/post/5ab10045518825557005db65" target="_blank" rel="noopener">令牌桶实现</a></li></ul></body></html>]]></content>
    
    <summary type="html">
    
      令牌桶算法浅析
    
    </summary>
    
    
      <category term="algorithm" scheme="https://blog.ikaroskun.xyz/categories/algorithm/"/>
    
      <category term="nginx" scheme="https://blog.ikaroskun.xyz/categories/algorithm/nginx/"/>
    
    
      <category term="algorithm" scheme="https://blog.ikaroskun.xyz/tags/algorithm/"/>
    
      <category term="nginx" scheme="https://blog.ikaroskun.xyz/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>链表-单链表</title>
    <link href="https://blog.ikaroskun.xyz/2017/08/02/alg-data-structure-single-linked-list/"/>
    <id>https://blog.ikaroskun.xyz/2017/08/02/alg-data-structure-single-linked-list/</id>
    <published>2017-08-02T14:14:29.000Z</published>
    <updated>2020-01-29T14:23:48.816Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script></head><body><h1 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h1><p>线性表实现的基本需要：</p><ul><li>能够找到表中的首元素（无论直接或间接，通常很容易做到）    </li><li>从表里的任一个元素出发，可以找到它之后的下一个元素</li></ul><p>实现线性表的一种方式是基于链接结构，用链接显式地表示元素之间的顺序关联。<br>基于链接技术实现的线性表称为链接表或链表</p><p>而链表有存在单向链表和双向链表，今天我们先介绍以下单向链表(单链表)</p><h1 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h1><p>链表的单元是节点 <code>Node</code></p><ul><li>每个结点（对象）有自己的标识（下面也常直接称其为链接）</li><li>结点之间通过结点链接建立起顺序联系</li><li>给表的最后一个结点（表尾结点）的链接域设置一个不会作为结点<br>对象标识的值（Python 里自然应该用 None），称为空链接</li></ul><h2 id="简单的节点实现代码："><a href="#简单的节点实现代码：" class="headerlink" title="简单的节点实现代码："></a>简单的节点实现代码：</h2><pre><code>class Node(object):    def __init__(self, x, nxt):        self.val = x        self.next = nxt</code></pre><h1 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h1><p>对单链表的基本操作有：</p><p>1.创建空链表:对于链表而言只需要将表头变量设置为空链接  </p><blockquote><p>在Python中我们将其设置为None即可</p></blockquote><p>2.删除链表:丢弃表的所有节点  </p><blockquote><p>在python中我们只需要简单的将表指针设为None，就丢掉了整个链表的所有节点，Python的存储管理系统会自动回收掉不用的存储。</p></blockquote><p>3.判断链表是否为空: 将表头变量的值与空链接进行比较</p><blockquote><p>在Python中我们只需要检查其值是否为None即可</p></blockquote><p>4.判断链表是否满</p><blockquote><p>链表不会满， 除非存储空间全部用完</p></blockquote><p>5.首端加入元素</p><blockquote><p>1）创建一个新结点存入数据<br>2）把原链表首节点的连接存入新结点的链接域<br>3) 修改表头变量使之引用新结点  </p></blockquote><p>6.尾端加入元素</p><blockquote><p>1) 创建一个新结点存入数据<br>2) 表空时直接让表头变量引用这个新结点并结束，否则找到表尾结点<br>3) 令表尾结点的链接域引用这一新结点，并将新结点的链接域设置为空链接</p></blockquote><p>7.定位加入元素</p><blockquote><p>1) 找到新结点加入位置的前一结点，不存在时结束<br>2) 创建新结点存入数据<br>3) 修改前一结点和新结点的链接域将结点连入</p></blockquote><p>8.首端删除元素</p><blockquote><p>直接修改表头指针，使之引用当时表头结点的下一个结点。<br>Python 系统里会自动回收无用对象的存储块，下同</p></blockquote><p>9.尾端删除元素</p><blockquote><p>找到倒数第二个结点，将其链接域设置为空链接</p></blockquote><p>10.定位删除元素</p><blockquote><p>找到要删除元素所在结点的前一结点，修改它的链接域将<br>要求删除的结点从表中去掉</p></blockquote><h1 id="代码定义"><a href="#代码定义" class="headerlink" title="代码定义"></a>代码定义</h1><h2 id="普通单链表"><a href="#普通单链表" class="headerlink" title="普通单链表"></a>普通单链表</h2><pre><code># 单向链表class SinglyLinkedList(object):    def __init__(self):        self.head = None    # 判空只需要判断指向的下一个节点是否为None    def is_empty(self):        return self.head is None    # 链表首端加入新元素    def prepend(self, element):        self.head = Node(element, self.head)    # 尾端加入新元素    def append(self, element):        # 判断是否为空链表, 是就直接添加        if self.head is None:            self.head = Node(element, None)            return        # 链表不为空, 遍历得到表里最后一个节点, 然后用这个节点的next域记录新结点的链接        p = self.head        while p.next is not None:            p = p.next        p.next = Node(element, None)    # 首端弹出元素    def pop(self):        if self.head is None:            raise ValueError        value = self.head.val        self.head = self.head.next        return value    # 弹出尾端元素    def pop_last(self):        # 首先判断是否为空链表        if self.head is None:            raise ValueError        p = self.head        # 如果链表只有一个元素        if p.next is None:            value = p.val            self.head = None            return value        # 遍历链表 直到找到最后一个节点, 将前一个节点的next置为None        while p.next.next is not None:            p = p.next        value = p.next.val        p.next = None        return value    # 查找元素    def find(self, element):        p = self.head        while p is not None:            if element == p.val:                return p.next.val            p = p.next        return None    # 打印出所有元素    def print_all(self):        p = self.head        while p is not None:            print(p.val, end="")            p = p.next        print("")</code></pre><h2 id="带有尾结点的单链表"><a href="#带有尾结点的单链表" class="headerlink" title="带有尾结点的单链表"></a>带有尾结点的单链表</h2><pre><code># 带尾结点引用的单链表  尾结点引用--->即指向最后一个节点# 较之上一个实现, 有效的解决了尾端插入的效率问题class SinglyLinkedListWithRearReference(SinglyLinkedList):    def __init__(self):        SinglyLinkedList.__init__(self)        self.rear = None    # 首端加入新元素    def prepend(self, element):        # 如果为空列表, 就将将元素置为第一个,并将尾节点引用指向当前节点        self.head = Node(element, self.head)        if self.rear is None:            self.rear = self.head    # 尾端加入新元素    def append(self, element):        if self.head is None:            # 直接调用首端加入, 对于第一个元素, 加入都是一致的            self.prepend(element)        else:            # 尾端加入新的元素时, 将尾结点引用指向当前新加入的节点            self.rear.next = Node(element, None)            self.rear = self.rear.next    # 从首端删除元素    def pop(self):        if self.head is None:            raise ValueError        value = self.head.val        # 如果尾结点引用指向了头结点, 那么说明 当前链表只有一个元素节点, 删除之后需要将尾结点引用置为None        if self.rear is self.head:            self.rear = None        # 将链表的头指向下一个元素节点        self.head = self.head.next        return value    # 从尾端删除元素    def pop_last(self):        if self.head is None:            raise ValueError        val = self.rear.val        p = self.head        while p.next.val != val:            p = p.next        p.next = None        self.rear = p</code></pre><h2 id="循环单链表"><a href="#循环单链表" class="headerlink" title="循环单链表"></a>循环单链表</h2><pre><code># 循环单链表  不必要使用单链表为基类class CircularSinglyLinkedList(object):    def __init__(self):        self.rear = None    # 判断是否为空    def is_empty(self):        return self.rear is None    # 首端加入新元素    def prepend(self, element):        p = Node(element, None)        # 如果是空链表，就要建立初始的循环链接， 即自己链接自己        if self.rear is None:            p.next = p            self.rear = p        # 链表不空，就要链接在尾结点之后， 就是首结点        else:            p.next = self.rear.next  # 先将原来的首结点链接在自己的后边            self.rear.next = p  # 自己成为首结点    # 尾端加入新元素    def append(self, element):        # 直接调用之前的加入操作        self.prepend(element)        # 将尾节点置换为新加入的结点        self.rear = self.rear.next    # 删除首端元素    def pop(self):        # 首先判断是否为空列表        if self.rear is None:            raise ValueError        p = self.rear.next        # 如果尾节点指向自己，说明只有一个结点， 弹出结点之后 将尾节点置空        if self.rear is p:            self.rear = None        # 正常情况下，删除首结点，并将首结点置为原来首结点的下一个        else:            self.rear.next = p.next        return p.val    # 删除尾端元素    def pop_last(self):        # 首先判断是否为空列表        if self.rear is None:            raise ValueError        p = self.rear.next        if p is self.rear:            self.rear = None            return p.val        while p.next is not self.rear:            p = p.next        p.next = self.rear.next        self.rear = p        return p.val    # 遍历所有结点    def print_all(self):        p = self.rear.next        while True:            print(p.val, end="")            if p is self.rear:                print("")                break            p = p.next</code></pre><h1 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h1><pre><code>from data_structure.link_list.singly_linked_list import SinglyLinkedList# 反序链表def reverse_by_singly(my_list):    """    使用修改链接关系：    1如果一直向首端添加结点，最先进去的就会在尾结点    2一直从首端取元素，最后得到的时尾结点。    这样就可以实现反转算法了    :param my_list: 被操作的链表    :return: 无    """    p = None    while my_list.head is not None:        q = my_list.head        my_list.head = q.next        q.next = p        p = q    my_list.head = p# 基于移动元素的单链表排序def sort_linked_list_by_move_value(my_list):    """    为了有效实现，算法只能从头到尾方向检查和处理。    每次拿出一个元素，在已排序的序列中找到正确位置插入    :param my_list: 被操作的链表    :return: 无    """    if my_list.head is None:        return    crt = my_list.head.next  # 计算从首结点之后开始，即首结点已排序完毕    while crt is not None:        x = crt.val        p = my_list.head        # 从原链表的首结点开始进行比较，存在如下情况        # 1. 当前结点的值大于已排序完毕的结点，跳过        while p is not crt and p.val <= x:            p = p.next        # 2. 当前结点的值小于已排序完毕的结点， 交换元素位置        while p is not crt:            x, p.val = p.val, x            p = p.next        crt.val = x        crt = crt.next# 基于调整链接关系实现排序工作def sort_linked_list_by_change_relation(my_list):    """    基本处理模式与移动元素类似.    但是这里不在结点之间移动表元素，而是把被处理的结点取下来接到正确的位置上。    :param my_list: 被操作的链表    :return: 无    """    # 判断链表是否为空    if my_list.head is None:        return    # 初始 已排序的段只有一个结点    last = my_list.head  # 表示已排序段的尾结点    crt = last.next      # 待排序段的首结点    # 顺序链表的结点，每次处理一个结点    while crt is not None:        # 设置扫描指针的初始值        p = my_list.head  # 已排序，并且比较完毕的段        q = None  # 已排序但为比较完毕的段        while p is not crt and p.val <= crt.val:            # 顺序更新两个扫描指针            q = p            p = p.next        # 当 p 是 crt 时 不需要修改链接，设置last到下一个结点crt        if p is crt:            last = crt        else:            # 取出当前结点            last.next = crt.next            # 接好后置链接            crt.next = p            if q is None:                # 作为新的首结点                my_list.head = crt            else:                # 接在表中间                q.next = crt        # crt 指向last的下一个结点        crt = last.next</code></pre><h2 id="Josephus-问题"><a href="#Josephus-问题" class="headerlink" title="Josephus 问题"></a>Josephus 问题</h2><p>使用循环单链表解决：</p><pre><code>"""@description: 经典问题 Josephus问题@author: merleLK@contact: merle.liukun@gmail.com@date: 17-8-2@detail: 问题描述：    设有n个人围坐一圈，现在从第k个人开始报数，报到第m的人退出。    然后继续报数，直至所有人退出。输出出列人顺序编号。"""from data_structure.link_list.singly_linked_list import CircularSinglyLinkedList# 基于list和固定大小的数组def josephus_list(n, k, m):    """    1.建立一个包含n个人（编号）的list    2.找到k个人， 从那里开始        处理过程中，把对应的表元素修改为0表示人已经退出    3.反复操作：        数m个（在席）人        把表示第m个人的元素修改为0    Tips: 数到list最后元素之后转到下标为0的元素继续    :param n: 列表的长度    :param k: 开始位置    :param m: 退出条件    :return: 无    """    people = list(range(1, n + 1))    print(people)    i = k - 1  # 开始位置的下标    for num in range(n):        count = 0  # 报数编号        # 一次循环最多到m， 此时就会把最后一个人踢出        while count < m:            if people[i] > 0:                count += 1            if count == m:                print(people[i], end="")                people[i] = 0            i = (i + 1) % n  # 遍历到最后一个位置就会从首位再次开始        print("," if num < n - 1 else "\n", end="")def josephus_list_pop(n, k, m):    """    1.算出应该退出的元素之后, 将其从表中删除    2.直至表长度为0的时候结束    复杂度： O(n^2)    :param n: 列表的长度    :param k: 开始位置    :param m: 退出条件    :return: 无    """    people = list(range(1, n + 1))    i = k - 1    for num in range(n, 0, -1):        i = (i + int(m) - 1) % num        print(people.pop(i), end="")        print("," if num > 1 else "\n", end="")class JosephusLinkedList(CircularSinglyLinkedList):    """    1.从形式看，循环单链表很好地表现了围坐一圈的人    2.顺序的数人头，很好的符合了循环表中沿着next链扫描    3.某人退出之后，删除相应结点，之后可以继续沿着原来的方向数人头    算法复杂度 O(m*n)    """    def __init__(self, n, k, m):        CircularSinglyLinkedList.__init__(self)        # 创建包含n个元素的循环链表        for i in range(n):            self.append(i + 1)        # 将初始结点移动到k处        self.turn(k - 1)        # 循环弹出第m个元素直到链表为空        while not self.is_empty():            self.turn(m - 1)            print(self.pop(), end="")            print("," if self.rear is not None else "\n", end="")    # 将循环表对象的rear指针沿着next移动了m步    def turn(self, m):        for i in range(m):            self.rear = self.rear.nextif __name__ == '__main__':    josephus_list(10, 2, 7)    josephus_list_pop(10, 2, 7)    JosephusLinkedList(10, 2, 7)</code></pre><p>源代码已经放置于我的 <a href="https://github.com/MerleLK/python-demo-small/tree/master/data_structure/link_list" target="_blank" rel="noopener">github</a>.</p></body></html>]]></content>
    
    <summary type="html">
    
      链表-单链表
    
    </summary>
    
    
      <category term="数据结构" scheme="https://blog.ikaroskun.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="链表" scheme="https://blog.ikaroskun.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/"/>
    
    
      <category term="数据结构" scheme="https://blog.ikaroskun.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="链表" scheme="https://blog.ikaroskun.xyz/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
</feed>
