<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ffmpeg使用笔记一]]></title>
    <url>%2F2017%2F10%2F27%2Fffmpeg%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[简介ffmpeg是处理音频和视频的程序，可以将音频和视频装换成流，并且包含了音频/视频的解码库libavcodec，提供了一套很完整的音视频解决方案。了解更多 相关资源ffmpeg官网地址 ffmpeg的Github项目地址 常用参数介绍主要参数 -i 跟输入文件 -f 设置输出格式 -y 输出文件已存在则覆盖该文件 -fs 超过制定的文件大小则结束转换 -ss 制定开始时间 -t 从-ss时间开始转换的持续时间 -title 设置标题 -timestamp 设置时间戳 -vsync 增减Frame使得影音同步 视频相关参数 -b:v 设置视频流量，默认为200Kbit/s -r 设置帧率 默认为25 -s 设置画面的宽和高 -aspect 设置画面的比例 -vn 不处理视频，于仅针对声音做处理时使用。 -vcodec(-c:v) 设置视频编解码器，未设置时使用与输入文件相同的编解码器 音频相关参数 -b:a 设置每个通道的流量 -ar 设置采样率 -ac 设置声音的通道数目 -acodec 设置音频编解码器，未设置时使用与输入文件相同的编解码器 -an 不处理声音，仅针对视频做处理时使用 -vol 设置音量大小，256为标准音量。（要设置成两倍音量时则输入512，依此类推。） 基础命令ffmpeg版本对应信息1、 查看当前版本所包含的编解码器 12345678ffmpeg -formats输出:D 3dostr 3DO STR E 3g2 3GP2 (3GPP2 file format) E 3gp 3GP (3GPP file format)D 4xm 4X Technologies E a64 a64 - video for Commodore 64 ...... 常见用法视频相关操作1、查看视频(音频)信息 ffmpeg -i test1.avi ffmpeg -i test2.mp3 2、将一组图片序列合成视频 12ffmpeg -f image2 -i image%d.jpg output.mpg# -i image%d.jpg 将当前目录下的image1.jpg、image2.jpg...包含 3、 将视频分解成图片序列 1ffmpeg -i test1.mpg image%d.jpg 4、将.mpg 装换成 .avi文件 1ffmpeg -i test1.mpg out.avi 5、 从视频中抽出声音，存为.mp3文件 1ffmpeg -i test1.avi -vn -ar 44100 -ac 2 -ab 192 -f mp3 sound.mp3 音频相关操作1、拼接多个音频 需求： 将test1.mp3和test2.mp3两个文件连接在一起。 12ffmpeg -i "concat:123.mp3|124.mp3" -acodec copy output.mp3# 其中 -acodec copy 表示重新编码并且复制到输出文件中。 2、 混合多个音频需求： 将test1.mp3和test2.mp3混合成一个音频，以第一个文件的长度为准。 123456789ffmpeg -i test1.mp3 -i test2.mp3 -filter_complex amix=inputs=2:duration=first:dropout_transition=2 -f mp3 output.mp3# --filter_complex: ffmpeg的滤镜功能# amix 表示混合多个音频到单个音频# inputs=2：表示输入两个音频文件，可以多个# duration：表示输出文件的长度 有多个参数# - longest 最长# - shortest 最短# - first 第一个文件长度# dropout_transition：输入流结束时（音频）容量重整化的转换时间（以秒为单位）。 默认值为2秒 3、 截取一个音频 需求： 截取test1.mp3音频文件的开始一分钟 123ffmpeg -i test1.mp3 -acodec copy -ss 00:00:00 -t 00:01:00 output.mp3# -ss 开始截取的时间点# -t 截取音频的时间长度 4、音频文件的格式转换 需求： 将test1.ape转换成test1.mp3格式 12345ffmpeg -i test1.ape -ar 4410 -ac 2 -ab 16k -vol|50 -f mp3 test1.mp3# -ar 设置音频采样频率# -ac 设置音频通道数# -ab 设置声音比特率# -vol 设置音量 256为标准音量。（要设置成两倍音量时则输入512，依此类推。） 参考文章 维基百科FFmpeg 官方文档ffmpeg ffmpeg音频合并]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>other</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux修改某用户默认Shell]]></title>
    <url>%2F2017%2F09%2F27%2FLinux%E4%BF%AE%E6%94%B9%E6%9F%90%E7%94%A8%E6%88%B7%E9%BB%98%E8%AE%A4Shell%2F</url>
    <content type="text"><![CDATA[问题:在Linux服务上，安装了Oh-My-Zsh.但是因为自己只是一个普通用户，所以要对自己用户下的默认shell进行设置。 方法：临时修改shell 我们可以对当前使用的shell进行改变，直接调用不同sheel名称进入到shell环境中去。 首先我们可以使用命令cat /etc/shells得到当前系统支持的shell环境。merle12345678910merle@bogon ~ ❯❯❯ cat /etc/shells /bin/sh /bin/bash /sbin/nologin /usr/bin/sh /usr/bin/bash /usr/sbin/nologin /bin/tcsh /bin/csh /bin/zsh 切换shell环境 12345merle@bogon ~ ❯❯❯ bash [merle@bogon ~]$ shsh-4.2$ csh[merle@bogon ~]$ zshmerle@bogon ~ ❯❯❯ 使用echo $SHELL可得到当前的shell环境。 修改用户默认的shel我们知道在linux系统的/etc/passwd文件内是保存系统内所有用户和用户的设置。 对某用户的默认设置也在这里。首先我们可以查看一下当前的用户设置。 12merle@bogon ~ ❯❯❯ grep merle /etc/passwd merle:x:1000:1000:merle:/home/merle:/bin/zsh 一、我们可以使用chsh命令修改某用户的默认shell 使用如下： 12345678910merle@bogon ~ ❯❯❯ chsh Changing shell for merle.New shell [/bin/bash]: /bin/zsh密码：Shell changed.merle@bogon ~ ❯❯❯# 再次查看该用户设置merle@bogon ~ ❯❯❯ grep merle /etc/passwd merle:x:1000:1000:merle:/home/merle:/bin/zsh 但是有可能系统不支持该命令。可以使用如下方法。 二、 使用usermod命令 用法如下： 12345usermod -s /bin/zsh merle# 再次查看该用户设置merle@bogon ~ ❯❯❯ grep merle /etc/passwd merle:x:1000:1000:merle:/home/merle:/bin/zsh 由上，我们可以在创建用户的时候指定默认shell. 1useradd -s /bin/zsh username give me a five.同步更新于简书笨猪_Merle]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[aiomysql文档一]]></title>
    <url>%2F2017%2F09%2F25%2Faiomysql%E6%96%87%E6%A1%A3%E4%B8%80%2F</url>
    <content type="text"><![CDATA[aiomysql官方文档aiomysql-API Rederence连接这个库提供了一种通过简洁的工厂级别的函数aiomysql.connect()去连接MySQL数据库的一种方式。如果你只想要存在一个连接，可以使用这种方式。对于多个连接可以考虑连接池。 示例： 123456789101112131415161718192021222324252627""" Just a demo for test the aiomysql."""import asyncioimport aiomysqlloop = asyncio.get_event_loop()@asyncio.coroutinedef test_example(): conn = yield from aiomysql.connect(host="127.0.0.1", port=3306, user="root", password="123456", db="mysql", loop=loop ) cur = yield from conn.cursor() yield from cur.execute("select Host, User from user") print(cur.description) result = yield from cur.fetchall() print(result) yield from cur.close() conn.close()loop.run_until_complete(test_example()) connect()函数的参数解析： connect(host=”localhost”, user=None, password=””, db=None, port=3306, unix_socket=None, charset=’’, sql_mode=None, read_default_file=None, conv=decoders, use_unicode=None, client_flag=0, cursorclass=Cursor, init_command=None, connect_timeout=None, read_default_group=None, no_delay=None, autocommit=False, echo=False, local_infile=False, loop=None): 一个连接MySQL的协程。 这个方法接受了所有来自pymsql.connect()的参数，并加上了关键字循环参数和超时参数。 字符串参数 host： 数据库服务所在的主机的地址。 默认为“localhost” 字符串参数 user：登录数据库的用户名 字符串参数 password：对应用户名的密码 字符串参数 db: 要使用的数据库， 如果没有指定不会使用其他的，报错。 整型参数 port：MySQL服务使用的端口，一般默认的就可以(3306). 字符串参数 unix_socket：可选的，你可以使用一个unix的socket，而不是一个TCP/IP。 字符串参数 charset： 指定你想要使用的编码格式，例如“utf8”。 参数 sql_model：默认使用的SQL模式，例如“NO_BACKSLASH_ESCAPES” 参数 read_default_file： 指定读取[client]部分的my.cnf文件。 参数 conv：使用指定编码器替代默认编码器，通常用来定制一些类型。 具体参考pymysql.converters 参数 user_unicode： 是否使用默认的unicode字符串 参数 client_flag： 自定义发送给mysql的flag，从pymysql.constants.CLIENT中可以找到相应的值。 参数 cursorclass：自定义使用的游标类 参数 str init_command：连接建立的时候执行的SQL初始化语句。 参数 connect_timeout：连接中抛出异常前的保持时间。 字符串参数 read_default_group：从配置文件中读取的分组信息 布尔参数 no_delay：禁止使用socket连接的纳格算法 参数 autocommit：自动提交模式，指定为None使用默认的值(default: False) 参数 loop：异步循环事件的实例，或者指定为None使用默认的实例。 return：返回值是一个连接的实例 MySQL服务器的socket的标志，获取链接实例的正确方法是调用aiomysql.connect()。 它的实例等同于pymsql.connection除了他的所有方法都是使用了协程。 最重要的方法是： aiomysql.cursor(cursor=None) 一个使用连接创建新游标对象的协程。 默认情况下， Cursor将被返回。也可以通过cursor参数给定一个自定义的cursor，但是他需要一个Cursor的子类。 Parameters: cursor- Cursor的子类，或者指定为None使用默认的cursor。 Returns： Cursor实例。 aiomysql.close() 立即关闭连接。 立即关闭连接，(除非del操作在执行)。从这之后连接将无法使用。 aiomysql.ensure_closed() 协程退出指令，然后会关闭socket连接。 aiomysql.autocommit(value) 指定当前session会话的自动提交模式是否可用的协程 Params：布尔值value： 切换自动提交模式 aiomysql.get_autocommit() 返回当前会话的自动提交模式的状态。 Reuturn： 布尔值 自动提交模式的状态 aiomysql.begin() 开启一个事务的协程。 aiomysql.commt() 提交更改到存储器的协程 aiomysql.rollback() 当前事务的rollback的协程 aiomysql.select_db(db) 选择当前数据库的协程 Paramters： 数据库(字符串)– 数据库的名字 aiomysql.closed() 如果连接关闭，返回一个只读的属性 True。 aiomysql.host MySQL服务器的IP地址或者主机名 aiomysql.port MySQL服务器的TCP/IP通信端口 aiomysql.unix_socket MySQL套接字文件的位置 aiomysql.db 当前数据库的名字 aiomysql.user 连接MySQL服务器的用户 aiomysql.echo 返回echo模式的状态(是否打印出SQL语句) aiomysql.encoding 当前连接使用的编码格式 aiomysql.charset 返回当前连接的字符集。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql命令笔记]]></title>
    <url>%2F2017%2F09%2F19%2FMysql%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Mysql相关的命令记录 记录一些用到的命令 docker相关1、创建一个mysql容器 1docker run --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=password -d mysql 2、docker登录进入到容器中 1docker exec -it (container_name/id) /bin/bash 数据库整体相关1、查看数据库的编码 1show variables like 'character%'; 2、查看数据表的定义 123-- 两者都行desc (table_name);describe (table_name); 3、创建新用户 首先使用root账户登录。 执行如下操作： 1insert into mysql.user(Host,User,authentication_string,ssl_cipher,x509_issuer,x509_subject) values("localhost","your-name",password("123456"),"","",""); 需要注意的是在mysql5.7之前的版本中authentication_string字段是对应Password字段的。 另外Host指定为localhost，表示只能本地访问，如果想要远程访问需要改为%。 登录新用户前需要重启一下mysql的服务。否则会报出错误。错误代码如下：ERROR 1045 (28000)。 4、删除用户 使用root账户登录。 执行如下操作： 12use mysql;Delete from user where User="your-name"; 5、将数据库的权限授予某个用户 使用root账户登录。 123456789101112-- 授权(所有权限)grant all privileges on test_g.* to name@localhost identified by '123456';-- 刷新权限表flush privileges;-- 授予某用户test数据库的某些权限(select, update)grant select,update on test.* to name@localhost identified by '123456';-- 授予某用户所有数据库的某些权限(此处被非本地主机)-- 要对本地主机授权，使用localhost替换 %grant select,delete,update,create,drop on *.* to name@"%" identified by "123456"; 其命令格式为： grant 权限 on 数据库.* to 用户名@登录主机 identified by “密码”; 6、展示当前运行的线程。 展示出当前正在运行的所有线程，子角色只能看到自己发起的线程。 1show processlist; 7、修改数据库的编码 mysql默认的编码是latin1。但是我们在使用的时候由于需要一些中文或者其他原因。需要更改数据库的编码格式。 创建数据库的时候可以指定编码格式。 1234567891011create database db_name character set utf8;``` a.命令行方式 &gt;此种方式不推荐使用，并且只在当前窗口有效。 ``` sqlset character_set_client=utf8;set character_set_connection=utf8;... b.修改配置文件my.cnf文件，位于/etc/mysql/my.cnf 需要重启生效 1234567-- 增加或者修改。[client]default-character-set=utf8[mysqlId]character-set-server=utf8default-character-set=utf8 8、展示数据表的状态信息 命令语法： 123SHOW TABLE STATUS [&#123;FROM | IN&#125; db_name] [LIKE 'pattern' | WHERE expr] 显示出当前数据库中的数据表的各种信息。 eg: 1show table status like "table_name"; 持续更新中。。。]]></content>
      <categories>
        <category>数据库</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渣翻之NeverWriteFor-LoopsAgain]]></title>
    <url>%2F2017%2F09%2F17%2F%E6%B8%A3%E7%BF%BB%E4%B9%8BNeverWriteFor-LoopsAgain%2F</url>
    <content type="text"><![CDATA[渣翻文章来自Randy Daw-Ran Liou ： Never Write For-Loops Again. 作者本人Blog 正文如下这是一个挑战，我挑战你去避免在每一个场景下写for循环。并且，我挑战你去寻找那些很难写出除了for循环之外的其他代码的场景，请分享出来。我很愿意去了解它们。 我开始探索Python语言中一些令人惊异的功能已经有一段时间了。在初始阶段，这只是一个我挑战我自己去使用更多的语言特性去代替我从其他语言上学习到的使用方法。然后事情变得很有趣。不仅仅是代码变得更加简短和干净，并且代码看起来更加的有结构和有规律。我将会在这篇文章中更深入这些益处。 但是，首先我们要退后一步去了解一下写一个for循环的直观原因： 通过遍历一个序列得到一些信息 通过当前序列生成一个新的序列 因为我是一个程序员，所以我很自然地去写for循环 幸运的是，在Python的内置模块中已经有很多很好的工具去帮助你达到这样的目标！你要做的只是改变你的思维去从另外一个角度理解。 你能在不写for循环中得到什么？ 更少的代码行数 更好的代码可读性 仅仅让缩进管理代码文本 让我们先看下面的代码结构 1234567# 1with ...: for ...: if ...: try: except: else: 在这个示例中，我们正在处理很多层的代码，这很难去阅读。我所发现的问题是这段代码通过给定的无处不在的缩进混合了管理逻辑(with和try-except)以及业务逻辑(for、if)。如果你只使用缩进去规范管理逻辑，那么你的业务就可以脱离出来。 “扁平优于嵌套” - Python之禅 你可以用来避免使用for循环的工具一、列表推导式 / 生成器表达式 我们可以先看这样一个简单的示例。你想要在一个已存在的序列上得到一个新的序列 12345678910result = []for item in item_list: new_item = do_something_with(item): result.append(item)``` 如果你喜欢MapReduce的话可以使用`map`或者Python拥有列表推导式。代码如下：``` pythonresult = [do_something_with(item) for item in item_list] 同样的如果你想要得到一个生成器，你可以使用生成器表达式，他们的语法很类似。(你怎么能不喜爱Python的一致性呢？)代码如下： 123456789result = (do_something_with(item) for item in item_list)``` 二、 函数从一个更高阶，更实用的编码方式，如果你想要映射一个序列到另一个序列，只需要使用`map`函数。(从我的理解，可以使用列表推导式代替它)``` pythondoubled_list = map(lambda x: x * 2, old_list) 如果你想要将一个序列生一个最终结果。可以使用reduce。123from functools import reduce summation = reduce(lambda x, y: x + y, numbers) 另外，很多Python的内置方法都可以使用迭代器(iterables)：123456789101112131415161718192021222324In [1]: a = list(range(10))In [2]: aOut[2]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]In [3]: all(a)Out[3]: FalseIn [4]: any(a)Out[4]: TrueIn [5]: max(a)Out[5]: 9In [6]: min(a)Out[6]: 0In [7]: list(filter(bool, a))Out[7]: [1, 2, 3, 4, 5, 6, 7, 8, 9]In [8]: set(a)Out[8]: &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;In [9]: dict(zip(a, a))Out[9]: &#123;0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9&#125;In [10]: sorted(a, reverse=True)Out[10]: [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]In [11]: str(a)Out[11]: '[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]'In [12]: sum(a)Out[12]: 45........... 三、提取函数或者生成器 上面两个方法很好的处理了简单的逻辑。那么怎么去处理复杂的逻辑呢？作为一个程序员，我们经常会把困难的事情抽象成函数。同样的方法也适用与这里。如果你写下面这样的代码： 1234567results = []for item in item_list: # setups # condition # processing # calculation result.append(result) 显然的你让一段代码承担了太多的责任。取而代之的，我建议你这样做： 12345678do process_item(item): # setups # conditions # processing # calculation return result results = [process_item(item) for item in item_list] 嵌套循环是怎么样的呢？ 1234results = []for i in range(10): for j in range(i): results.appens((i, j)) 列表表达式这样帮助你： 123results = [(i, j) for i in range(10) for j in range(i)] 如果你想在代码中保存一些内部的状态怎么办呢？ 123456789# finding the max prior to the current itema = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8]results = []current_max = 0for i in a: current_max = max(i, current_max) results.append(current_max)# results = [3, 4, 6, 6, 6, 9, 9, 9, 9, 9] 让我们抽象成一个生成器去做到这样的功能： 12345678def max_generatir(numbers): current_max = 0 for i in numbers: current_max = max(i, current_max) yield current_max a = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8]results = list(max_generator(a)) Oh! 等一下， 你刚刚在代码段中使用了一个for循环， 这是欺骗！ 好啦，自作聪明的家伙，让我们试一下下面的。 四、不要自己写，itertools已经写了 这个模块(itertools)简直精彩极了。我相信这个模块实现了80%的你想写for循环的情况。举个栗子， 刚才的最后一个示例可以被这样重写：1234from itertools import accumulate a = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8]results = list(accumulate(a, max)) 当然，如果你要迭代一个组合的序列， 你可以使用product()、permutations()、combinations()。 结论 你在大多数场景下是不需要写for循环的 为了拥有更好的代码可读性，你应当避免使用for循环 行动 再次查看你的代码，找到那些你凭借直觉写for循环的地方。再次思考一下，看看是否可以不使用for循环去重写它。 分享你的那些很难不使用for循环的例子。 – 菜鸟级别的翻译。。见谅。嘻嘻]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库之存储过程和函数简介]]></title>
    <url>%2F2017%2F08%2F28%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8B%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E5%87%BD%E6%95%B0%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[简介什么是存储过程和函数？ 首先我们要知道过程化SQL主要有两种类型，即命名块和匿名块。所谓匿名块即是我们在程序中所直接写的SQL语句， 每次执行都要编译，它不会存储到数据库中，也不能在其他过程化SQL块中调用。而存储过程和函数则是命名块，它们被编译后保存在数据库中，称为持久性存储模块。可以被反复调用，并且运行速度较快。 详细介绍存储过程一、概念 存储过程是由过程化SQL语句书写的过程，这个过程经过编译和优化之后存储在数据库服务器中，因此称之为存储过程，在使用的时候直接调用即可。 简单来说，就是由一些T-SQL语句组成的代码块，像一个方法一样实现了一些功能，例如对单表和多表的CRUD操作，然后再给这个代码块取一个名字，再用到此功能调用就可以了。 二、优点 我们知道数据库执行SQL语句时，是先编译优化，再执行。而存储过程则是已经编译完毕的代码块。无需再次执行编译过程，所以它的运行效率高。提供了在服务器端快速执行SQL语句的有效途径。 客户机上的应用程序只需要提供调用存储过程的名称和参数，就可以执行一个复杂的存储过程，并进行相应的数据处理，只需要把最终的处理结果返回给客户端。这就降低了客户机和服务端的通信量，提高了通信的效率。 使用存储过程能够使得没有权限的用户在控制之下间接的存取数据，一定程度上保证了数据的安全。 如果对数据库中的数据的某些规则是动态的，我们可以将这些规则写成存储过程，如果这些规则发生变化，我们只需要修改对应的存储过程即可，而不是去修改应用程序的源代码。 三、缺点 不便于调试。在做性能调优的时候，无法显示内部的查询计划。 不方便移植到其他数据库。在使用存储过程时，对于不同的数据库，对应的存储过程的定义方式不同，支持的语言以及语法不同，移植的成本很高。 四、基本使用 我们可以通过如下SQL语句创建、执行、修改和删除存储过程。 1、创建存储过程 123CREATE OR REPLACE PRODUCRE 过程名([arg1, arg2...])AS&lt;过程化SQL语句块&gt;; 2、执行存储过程 1CALL/PERFORM PROCEDURE 过程名([arg1, arg2...]) 3、修改存储过程 1234-- 重命名存储过程ALTER PROCEDURE 过程名1 RENAME TO 过程名2-- 重新编译存储过程ALTER PROCEDURE 过程名 COMPILE 4、删除存储过程 1DROP PROCEDURE 过程名() 函数一、概念 函数也称自定义函数，因为是用户自己使用过程化SQL语句设计定义的。函数和存储过程类似，都是持久性存储模块。 Tips: 不同之处：函数必须指定返回的类型 二、基本语法格式 1、函数定义语句 1234CREATE OR REPLACE FUNCTION 函数名([arg1, arg2...]) RETURNS &lt;类型&gt;AS&lt;过程化SQL语句块&gt;； 2、函数执行格式 1CALL/SELECT 函数名([arg1, arg2...]); 3、修改函数 1234-- 重命名函数ALTER FUNCTION 函数名1 RENAME TO 函数名2;-- 重新编译函数ALTER FUNCTION 函数名 COMPILE; PostgreSQL中的存储过程(函数)简介PostgreSQL对存储过程的描述是：存储过程和用户自定义函数（UDF）是SQL和过程语句的集合，它存储于数据库服务器并能被SQL接口调用。 PostgreSQL官方支持PL/pgSQL，PL/Tcl，PL/Perl和PL/Python这几种过程语言，同时还支持一些第三方提供的过程语言，如PL/JAVA，PL/PHP，PL/R，PL/Scheme，PL/sh。 注意：PostgreSQL数据库并没有区分存储过程和函数。 基于SQL的存储过程定义方式 123456-- 创建一个查询所有结果的函数CREATE OR REPLACE FUNCTION GetAllUser()RETURNS RECORDAS $$SELECT * FROM USERS$$ LANGUAGE SQL; 调用方式 1select GetAllUser(); 基于PL/PgSQL的存储过程定义PL/PgSQL是一个块结构语言，函数定义的所有文本都必须是一个块。参考More其定义如下： 123456[&lt;&lt;label&gt;&gt;][ DECLARE declaerations]BEGIN statementsEND [lable]; 一个简单的例子： 1234567CREATE OR REPLACE FUNCTION GetUser()RETURNS setof users AS $$BEGIN SELECT * FROM USERS;END;$$ LANGUAGE PLPGSQL; 调用返回格式 1select GetUser() 返回所有的users表中的结果 参考文献 http://www.postgres.cn/docs/9.5/plpgsql-declarations.html http://www.jasongj.com/2015/12/27/SQL4_%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B_Store%20Procedure/ http://www.cnblogs.com/knowledgesea/archive/2013/01/02/2841588.html https://my.oschina.net/Kenyon/blog/108303 数据库系统概论第五版—-王珊]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python实现单例模式总结]]></title>
    <url>%2F2017%2F08%2F19%2FPython%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[单例模式在某些情况下，有些对象我们只需要一个就可以了，比如，一台计算机上可以连接好多个打印机，但是这个计算机的打印机程序只能有一个，所以我们在这里就可以使用单例模式来避免两个打印作业同时输出到打印机中。相似的例子还有数据库的连接实例。 所谓单例模式，又叫单件模式，其作用就是保证整个应用程序的生命过程中，任何一个时刻，单例类的示例都之只存在一个(也可以不存在)。 单例模式特点： 单例类只能有一个实例； 它必须自行创建这个实例； 它必须自行向整个系统提供这个实例 Python实现单例模式使用__new__方法。首先我们明确一件事情，__init__方法不是Python对象的构造方法，__init__方法只负责初始化实例对象， 在调用__init__方法之前，会首先调用__new__方法去生成一个对象，所以对于Python来说，__new__方法可以被认为是构造方法。 我们可以在__new__方法中加以控制，使得某个类只生成唯一对象。 实现如下： 123456789101112131415class Singleton(object): def __new__(cls, *args, **kwargs): if not hasattr(cls, '_instance'): cls._instance = super(Singleton, cls).__new__(cls, *args, **kw) return cls._instance # 测试代码 one = MyClass()two = MyClass()two.a = 3print(one.a) # 3print(id(one)) # 139640940865520 print(id(two)) # 139640940865520 优点：相比装饰器，这是一个真正的类缺点：要使用多重继承， __new__方法可能会被重写，单例实现可能会被覆盖 使用共享属性通过对单例的理解，我们可以想到，它就是所有引用(实例，对象)都拥有相同的状态(属性)和行为(方法).所以我们可以将不同的对象指向相同的方法和属性即可。 在Python中，__dict__用字典保存了类的所有属性和变量。所以我们可以将不同的对象的__dict__指向同一个字典即可。 代码如下： 123456789101112131415161718class SingletonByShare(object): _state = &#123;&#125; def __new__(cls, *args, **kwargs): ob = super().__new__(cls) ob.__dict__ = cls._state return ob# 测试代码：one = MyClass()two = MyClass()two.a = 3print(one.a) # 3print(id(one)) # 139779908835312print(id(two)) # 139779908834808print(id(one.__dict__)) # 139779883542208print(id(two.__dict__)) # 139779883542208 我们发现one和two其实是两个不同的对象，但是它们包含的属性和方法字典是一样的。也就是实现了单例。 使用metaclass实现代码如下： 123456789101112131415161718192021222324class SingletonByMetaClass(type): _instances = &#123;&#125; def __call__(cls, *args, **kwargs): if cls not in cls._instances: cls._instances[cls] = super(SingletonByMetaClass, cls).__call(\*args,\*\*kw ) return cls._instances[cls]# 测试代码 Python3class MyClass(object, metaclass=SingletonByMetaClass): a = 1# Python2class MyClass(object): __metaclass__ = SingletonByMetaClass a = 1one = MyClass()two = MyClass()two.a = 3print(one.a)print(id(one))print(id(two)) 优点： 是一个真正的类，达到了多重继承的效果，而不会被重写缺点： 没有其他方式的实现清晰 使用装饰器实现这是一种更pythonic,更elegant的方法，单例类并不知道自己是单例类。 代码如下： 1234567891011121314151617def singleton_by_decorator(cls, *args, **kwargs): _instances = &#123;&#125; def wrapper(): if cls not in _instances: _instances[cls] = cls(\*args, \*\*kwargs) return _instances[cls] return wrapper# 测试代码one = MyClass()two = MyClass()two.a = 3print(one.a) # 3print(id(one)) # 139683020176072print(id(two)) # 139683020176072print(type(MyClass)) # &lt;class 'function'&gt; 优点：直接添加在类定义代码上面，比多重继承更加直观缺点：类调用的时候 myclass()是一个单例对象，但是myclass本身变成了一个方法，而不是一个类，因此不能调用这个类的类方法.并且如果A的类型发生变化之后产生的负面作用是很难把握的。 使用import模块将类作为模块让其他的包去引用，是天然的单例模式。 代码实现： 123456789101112# singleton_by_import.pyclass SingletonByImport(object): def foo(self): passsingleton = SingletonByImport()# other file from singleton_by_import import singleton singleton.foo() 这是比较简单和容易理解的一种实现方式。 参考资料： https://stackoverflow.com/questions/6760685/creating-a-singleton-in-pythonhttp://blog.csdn.net/ghostfromheaven/article/details/7671853http://whosemario.github.io/2016/01/22/pattern-singleton/]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python中常见的坑]]></title>
    <url>%2F2017%2F08%2F18%2FPython%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[简介在Python中也会有很多陷阱，在网上看到一篇文章，在此处记录以下，菜鸡翻译。 参考来源在下方。 问题集合类变量问题 下面的代码将会输出什么？ 并解释。 1234567891011def extend_list(value, my_list=[]): my_list.append(value) return my_listlist1 = extend_list(10)list2 = extend_list(123, [])list3 = extend_list('a')print('list1 is: &#123;&#125;'.format(list1))print('list2 is: &#123;&#125;'.format(list2))print('list3 is: &#123;&#125;'.format(list3)) 答案揭晓： 1234# output:list1 is: [10, 'a']list2 is: [123]list3 is: [10, 'a'] 许多人会误认为list1输出[10],list3将会输出[&#39;a&#39;]，以为参数my_list将会在调用extend_list函数的使用被设置为默认的值[]. 然而并非如此。在实际上发生的事情是，一个新的列表只会在函数被定义的时候创建一次。并且在extend_list函数被调用的时候，如果没有指定my_list的参数，那么它们将会使用同一个列表(也就是定义的时候初始化的那个)。 所以上边的例子中，list1和list3操作的是同一个列表。而list2则是在它自己创建的空列表中进行操作(通过把自己的空列表作为函数的参数传递给了函数)。 那么我们该如何修改上边的函数定义？来让它实现我们期望的功能呢？修改函数定义如下： 12345def extend_list(value, my_list=None): if my_list is None: my_list = [] my_list.append(value) return my_list 就是说如果在没有指定my_list参数的值时，我们重新创建一个空列表。 输出如下： 123list1 is: [10]list2 is: [123]list3 is: ['a'] Tips：我在Pycharm中写这样的代码时， 还有一个警告信息，信息的内容大致就是上边我们所说的会出现的这种问题。神奇！！ late binding(后期绑定)的问题下面的代码会输出什么？ 请解释。 1234def multipliers(): return [lambda x: i * x for i in range(4)]print([m(2) for m in multipliers()]) 答案揭晓： 12# output:[6, 6, 6, 6] 是不是有点慌？程序的输出不是我们期待的[0, 2, 4, 6]而是[6, 6, 6, 6]。 这个原因主要是Python闭包的后期绑定late binding造成的。这就意味着在闭包中变量的值是在内部函数被调用的时候才去寻找的。 所以造成的结果就是，在任何时候由multiplers()函数返回的函数集合被调用，变量i的值才会在那个时候去从它被调用时的作用域中查找。 在那时，不管在被返回的函数集合中的哪个函数被调用，for循环是已经完成的，而变量i已经被指定为了最终的值3。因此，被返回的函数集合中的每个函数中的i都是3，所以在参数2被传递进入函数中，函数执行的操作其实是2*3，也就是6。 顺便说一点，就像The Hitchhiker’s Guide to Python指出的那样，人们存在一个误解，以为这种问题是由lambda函数造成的，其实不然，由lambda关键字创建的函数和由def关键字创建的函数是没什么不一样的。 下面我们给出一些解决这种问题的方法。 1.使用Python的生成器 123def multipliers(): for i in range(4): yield lambda x: i * x 2.创建一个闭包，通过使用默认参数立即绑定到它的参数上。 12def multipliers(): return [lambda x, i=i: i * x for i in range(4)] 3.使用funtiontoos模块中的partial进行改写。 12345from functools import partialfrom operator import muldef multipliers(): return [partial(mul, i) for i in range(4)] 4.在其他资料上我也发现了另外一种方法。 12def multipliers(): return (lambda x: i * x for i in range(4)) 类变量的问题下面的代码会输出什么？请解释。 1234567891011121314class Parent(object): x = 1class ChildFirst(Parent): pass class ChildSecond(Parent): pass print(Parent.x, ChildFirst.x, ChildSecond.x)ChildFirst.x = 2print(Parent.x, ChildFirst.x, ChildSecond.x)Parent.x = 3print(Parent.x, ChildFirst.x, ChildSecond.x) 答案揭晓： 1231 1 11 2 13 2 3 WTF? 为什么最后一行输出不是3 2 1而是3 2 3? 为什么改变了Parent.x的值竟然也改变了ChildSecond.x的值。但是却没有改变ChildFirst.x的值？ 这个问题的答案的关键是： 在Python中，类变量在内部是作为字典来处理的。 如果一个变量名没有在当前类的变量字典中找到，就会去搜索父类的变量字典，如果在一直延续到在顶层的祖先类的字典中也没有找到该变量。就会报出一个AttributeError的异常。 因此，在Parent中设置了类变量x=1，在该类和其任何子类的的变量引用中生效x=1.这就是为什么第一行输出1 1 1。 然后，如果某一个子类重写了这个变量，就像我们执行了ChildFirst.x=2，这个值会仅仅在这个子类中发生变化。这就是为什么第二行输出1 2 1。 最后，如果在父类Parent中改变。就会使得所有没有重写这个变量的子类中的该变量的值发生变化。就是最后一行输出3 2 3的原因。 除法操作的问题下面的代码在Python2环境下输出是什么？ 请解释. 12345678910def div1(x, y): print "&#123;&#125;/&#123;&#125;=&#123;&#125;".format(x, y, x/y)def div2(x, y): print "&#123;&#125;/&#123;&#125;=&#123;&#125;".format(x, y, x//y)div1(5,2)div1(5.,2)div2(5,2)div2(5.,2.) 答案揭晓： 12345/2 = 25.0/2 = 2.55//2 = 25.0//2.0 = 2.0 默认情况下，如果两个操作数都是整数，Python2就会自动执行整型计算，所以结果是5/2=2, 然后5./2=2.5. 注意，你可以在Python中重载这个方法达到在Python3中输出的结果，通过以下方式 1from __future__ import division 此时输出： 12345/2 = 2.55.0/2 = 2.55//2 = 25.0//2.0 = 2.0 并且注意 双斜线//操作符一直执行整型运算，所以在Python2中输出5.0//2.0 = 2.0。 在Python3中输出是和上边引入division的输出是一致的。 注意，在Python3中/操作符是做浮点除法，而//是做整除(保留商，余数舍弃)，有意思的是： Python3中(-7) // 3 = -3因为它的整型运算是向更小的数值取值(即向下取整)。例7 // 2 = 2。 列表的问题1下面代码会输出什么？ 12my_list = ["a", "b", "c", "d", "3"]print(my_list[10:]) 答案揭晓： 12# output:[] 上边的代码会输出[],而不是一个IndexError的异常。 正如人们所预料的， 试图使用超过成员数量的索引访问列表的成员(eg..my_list[10])会报出IndexError异常。 但是试图以一个超出列表成员数量的索引作为开始索引的切片操作不会导致下标异常，仅仅是返回一个空列表。 一个特别严重的问题是，它可能导致的错误，但是很难追踪到，因为它并没有出现运行错误。 列表的问题2思考下面的代码片段： 123456781. list = [ [ ] ] * 52. list # output?3. list[0].append(10)4. list # output?5. list[1].append(20)6. list # output?7. list.append(30)8. list # output? 答案揭晓： 1234[[], [], [], [], []][[10], [10], [10], [10], [10]][[10, 20], [10, 20], [10, 20], [10, 20], [10, 20]][[10, 20], [10, 20], [10, 20], [10, 20], [10, 20], 30] 第一行的输出是直观的，也很容易理解，仅仅是创建了5个列表的列表。 但是，理解问题的关键是list = [ [ ] ] * 5并不是创建了5个不同的列表，而是对一个列表的5个引用，有了这层理解我们对下面的输出就好理解了。 list[0].append(10)在第一个列表中添加了元素10， 其他列表都是对同一个列表的引用，所以输出如上。 同样的道理，第二个列表添加了元素20，也是对同一个列表进行的操作。 相反，list.append(30)则是添加了一个元素到外层列表中，也就是说， 30是和剩下的5个列表同一层级的(个人理解)。所以输出如上。 列表的问题3给定n个数的列表，使用单列表理解来生成只包含如下这些值的新列表。 偶数 索引也是偶数 我们可以采用如下代码完成这个工作： 1[x for x in my_list[::2] if x % 2 == 0] 示例： 1234my_list = [ 1 , 3 , 5 , 8 , 10 , 13 , 18 , 36 , 78 ]new_list = [x for x in my_list[::2] if x % 2 == 0]#output:[10, 18, 78] 参考文章 https://www.toptal.com/python/interview-questionshttp://docs.python-guide.org/en/latest/writing/gotchas/]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构之堆]]></title>
    <url>%2F2017%2F08%2F15%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%A0%86%2F</url>
    <content type="text"><![CDATA[数据结构—–堆]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我学算法之常见的排序算法]]></title>
    <url>%2F2017%2F08%2F15%2F%E6%88%91%E5%AD%A6%E7%AE%97%E6%B3%95%E4%B9%8B%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[背景按照相关排序算法的解释，手动用Python实现了一遍，记录一下。排序结果为从小到大。 安利一个学习算法的经典网站：算法图示 这个网站上有很多算法的动图示例，还带有操作步骤解释，实在是居家旅行学习必备之网站。 冒泡排序原理 冒泡排序的原理是将临近的数字两两进行比较，然后按照从小到大或者从大到小的顺序进行交换。 动图如下： 步骤 主要步骤如下： 比较相邻的前后二个数据，如果前面数据大于后面的数据，就将二个数据交换。 按照1的方法对源数组的第0个数据到N-1个数据进行一次遍历后，最大的一个数据就“升”到数组第N-1个位置（就是最后一个位置）。 设置N=N-1，如果N不为0就重复前面二步，如果N==0，那么就是将原数组所有的数都排序一遍，此时排序完成。 代码实现 12345678def bubble_sort(array): length = len(array) while length &gt; 0: for i in range(length - 1): if array[i] &gt; array[i + 1]: array[i], array[i + 1] = array[i + 1], array[i] length -= 1 return array 基本优化 1.对于结束的条件，如果遍历某一趟时，没有发生任何交换，说明此时排序已经完成，所以我们可以在程序中加上一个标志量用来表示某趟是否发生交换。 代码如下： 1234567891011121314def bubble_sort_better(array): length = len(array) flag = False while length &gt; 0: for i in range(length - 1): if array[i] &gt; array[i + 1]: array[i], array[i + 1] = array[i + 1], array[i] flag = True else: flag = False if flag is False: return array length -= 1 return array 2.如果存在这样的数组： 假设数组有100个数，但是只有前10个是无序的，后面90个是已经排序完毕，且均大于前面10个数。这样我们分析即可发现，第一趟遍历的时候，最后发生交换的位置必定小于10。所以我们只需要记录下这个最后的位置，下一次，只需要从头遍历到这个位置即可。 代码如下： 123456789def bubble_sort_best(array): length = len(array) while length &gt; 0: for i in range(length - 1): if array[i] &gt; array[i + 1]: array[i], array[i + 1] = array[i + 1], array[i] length = i + 1 length -= 1 return array 直接插入排序原理 插入排序的基本思想就是：每次将一个待排序的记录，按其关键字大小插入到前面已经排好序的子序列中的适当位置，直到全部记录插入完成为止。 动图效果如下： 步骤 设数组为a[0…n-1]。 从第一个元素开始，该元素可以认为已经被排序 取出下一个元素，在已经排序的元素序列中从后向前扫描 如果该元素（已排序）大于新元素，将该元素移到下一位置 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置 将新元素插入到该位置中 重复步骤2 代码实现 12345678def insert_while(nums): for index in range(1, len(nums)): deal_num = nums[index] j = index - 1 while j &gt;= 0 and nums[j] &gt; deal_num: nums[j + 1] = nums[j] j -= 1 nums[j + 1] = deal_num 希尔排序原理 希尔排序，也称递减增量排序算法，实质是分组插入排序。由 Donald Shell 于1959年提出。希尔排序是非稳定排序算法。 希尔排序是基于插入排序的以下两点性质而提出改进方法的： 插入排序在对几乎已经排好序的数据操作时， 效率高， 即可以达到线性排序的效率 但插入排序一般来说是低效的， 因为插入排序每次只能将数据移动一位 希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。 步骤 我们以一组数[49, 38, 65, 97, 26, 13, 27, 49, 55, 4]为例。 加入首先我们以步长5排序 49 38 65 97 2613 27 49 55 4 然后我们对每列进行排序。 13 27 49 55 449 38 65 97 26 合并变成了[13, 27, 49, 55, 4, 49, 38, 65, 97, 26]。第一轮结束。 更换步长为5//2=2,继续排序 13 2749 554 4938 6597 26 排序过后 4 2613 2738 4949 5597 65 合并：[4,26,13,27,38,49,49,55,97,65] 更换步长为2//1=1排序之后就得到了结果。 代码实现 12345678910111213141516def shell_sort(array, n): step = 2 now_gap = n // step # 初始步长 while now_gap &gt; 0: for i in range(now_gap, n): # 每个步长进行插入排序 temp = array[i] j = i # 插入排序 while j &gt;= now_gap and array[j - now_gap] &gt; temp: array[j] = array[j - now_gap] j = j - now_gap array[j] = temp # 新的步长 now_gap //= step return array 基本优化 优化部分主要在与步长的选择上，请移步维基百科8F#.E6.AD.A5.E9.95.BF.E5.BA.8F.E5.88.97)上查阅。当前比较优秀的步长序列有： 已知的最好步长序列是由Sedgewick提出的(1, 5, 19, 41, 109,…)，该序列的项来自这两个算式。这项研究也表明“比较在希尔排序中是最主要的操作，而不是交换。”用这样步长序列的希尔排序比插入排序要快，甚至在小数组中比快速排序和堆排序还快，但是在涉及大量数据时希尔排序还是比快速排序慢。 另一个在大数组中表现优异的步长序列是（斐波那契数列除去0和1将剩余的数以黄金分区比的两倍的幂进行运算得到的数列）：(1, 9, 34, 182, 836, 4025, 19001, 90358, 428481, 2034035, 9651787, 45806244, 217378076, 1031612713,…) 直接选择排序原理 直接选择排序和直接插入排序类似，都将数据分为有序区和无序区，所不同的是直接插入排序是将无序区的第一个元素直接插入到有序区以形成一个更大的有序区，而直接选择排序是从无序区选一个最小的元素直接放到有序区的最后。 步骤 在给定的数组中找到最小(大)的元素，将其放置为数组的首位作为已排序区域。 继续在剩下的数组区域中寻找最小(大)的元素，放置到已排序区域的后边。 重复2步知道剩下的元素排序完毕。 动图示例： 代码实现 12345678def select_sort(array): for i in range(len(array)): min_index = i for j in range(i + 1, len(array)): if array[j] &lt; array[min_index]: min_index = j array[min_index], array[i] = array[i], array[min_index] return array 归并排序原理 归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。它的思想就是先递归分解数组，再合并数组。 首先是合并两个数组。思路如下：比较两个数组的最前面的数字，取小的那个，取了之后就要从原来的数组中删除这个数字。 然后继续比较，知道一个数组为空，最后把另一个数组的剩余部分复制过来即可。 再者考虑递归分解。思路如下：将数组分为left和right，如果这两个数组内部有序，就合并这两个数组。确定两个数组内部有序的方法是，持续二分，知道每个小组中只有一个数字，此时该小组就认为有序。然后合并相邻两个小组。 动图演示： 代码实现 12345678910111213141516171819202122232425262728def merge_array(array1, array2): left_index = right_index = 0 result = [] # 循环比较两个数组，知道某个数组为空 while len(array1) &gt; left_index and len(array2) &gt; right_index: if array1[left_index] &lt; array2[right_index]: result.append(array1[left_index]) left_index += 1 else: result.append(array2[right_index]) right_index += 1 # 将不为空数组剩下的数字依次加入到结果列表中。另一个是空列表，所以可以这样实现。 result += array1[left_index:] result += array2[right_index:] return result def divide_array(array): # 结束条件 if len(array) &lt;= 1: return array index = len(array) // 2 left = divide_array(array[:index]) # 左半部分 right = divide_array(array[index:]) # 右半部分 return merge_array(left, right) 快速排序原理 快速排序通常明显比同为Ο(n log n)的其他算法更快，因此常被采用，而且快排采用了分治法的思想，所以在很多笔试面试中能经常看到快排的影子。可见掌握快排的重要性。 步骤 先从数列中取出一个数作为基准数。 分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。 再对左右区间重复第二步，直到各区间只有一个数 动图示例： 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041# 普通实现def quick_sort_simple(array): if len(array) &lt;= 1: return array key = array[0] less, greater = [], [] for i in range(1, len(array)): if array[i] &gt; key: greater.append(array[i]) else: less.append(array[i]) return quick_sort_simple(less) + [key] + quick_sort_simple(greater)# 使用列表推导式实现def quick_sort_nic(array): if len(array) &lt;= 1: return array return quick_sort_nic([x for x in array if x &lt; array[0]]) + [x for x in array if x == array[0]] + quick_sort_nic([x for x in array if x &gt; array[0]]) # 不开辟空间实现def quick_sort(ary): return qsort(ary,0,len(ary)-1)def qsort(ary,left,right): #快排函数，ary为待排序数组，left为待排序的左边界，right为右边界 if left &gt;= right : return ary key = ary[left] #取最左边的为基准数 lp = left #左指针 rp = right #右指针 while lp &lt; rp : while ary[rp] &gt;= key and lp &lt; rp : rp -= 1 while ary[lp] &lt;= key and lp &lt; rp : lp += 1 ary[lp],ary[rp] = ary[rp],ary[lp] ary[left],ary[lp] = ary[lp],ary[left] qsort(ary,left,lp-1) qsort(ary,rp+1,right) return ary 堆排序原理 堆排序与快速排序，归并排序一样都是时间复杂度为O(N*logN)的几种常见排序方法， 首先我们要理解数据结构中的二叉堆。具体介绍请移步文章数据结构之堆。 我们知道二叉堆的两大性质： 父节点的键值总是大于或者等于任何一个子节点的键值。 每个节点的左右子树都是一个二叉树堆(都是最大堆或者是最小堆) 步骤 构建最大堆(Build_Max_Heap):若数组下标范围为0~n，考虑到单独一个元素的大根堆，则从下标n/2开始的元素均为大根堆。于是只要从n/2-1开始，向前依次构造大根堆，这样就保证，构造到某结点时，它的左右子树都已经是大根堆。 堆排序(HeapSort):由于堆是用数组模拟的。得到一个大根堆后，数组内部并不是有序的。因此需要将堆化数组有序化。 这种操作的思想是：移除根节点，并做最大堆调整的递归运算。第一次将heap[0]与heap[n-1]交换，再对heap[0...n-2]做最大堆调整。第二次将heap[0]与heap[n-2]交换，再对heap[0..n-3]做最大堆调整。重复该操作直至heap[0]和heap[1]交换。由于每次都是将最大的数字并入到后边的有序区间。所以操作完成时，整个数组就是有序的了。 最大堆调整(Max_Heapify)：该方法是被调用的，目的是将堆的末端子结点作调整。使得子结点永远小于父节点。 动图演示： 代码实现 1234567891011121314151617181920212223242526def heap_sort(ary): n = len(ary) first = int(n / 2 - 1) # 最后一个非叶子节点 for start in range(first, -1, -1): # 构造大根堆 max_heapify(ary, start, n - 1) for end in range(n - 1, 0, -1): # 堆排，将大根堆转换成有序数组 ary[end], ary[0] = ary[0], ary[end] max_heapify(ary, 0, end - 1) return ary# 最大堆调整：将堆的末端子节点作调整，使得子节点永远小于父节点# start为当前需要调整最大堆的位置，end为调整边界def max_heapify(ary, start, end): root = start while True: child = root * 2 + 1 # 调整节点的子节点 if child &gt; end: break if child + 1 &lt;= end and ary[child] &lt; ary[child + 1]: child = child + 1 # 取较大的子节点 if ary[root] &lt; ary[child]: # 较大的子节点成为父节点 ary[root], ary[child] = ary[child], ary[root] # 交换 root = child else: break 相关代码都放置在了我的github 参考资料： http://blog.csdn.net/morewindows/article/category/859207 http://wuchong.me/blog/2014/02/09/algorithm-sort-summary/ https://visualgo.net/zh/sorting]]></content>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cython编译的坑]]></title>
    <url>%2F2017%2F08%2F15%2FCython%E7%BC%96%E8%AF%91%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[背景在项目后期，需要将产品进行发布，为了保护代码安全，最终选定将代码文件利用Cython编译成C的扩展。 有关Cython的介绍在官网上也有详细的说明。 这里只记录几个问题。 问题不同包内模块同名问题在复杂的包层次结构中，很容易出现相同的模块名，这种问题，在python中也是一个比较常见的问题，我在之前的一个博客上Python的import有所介绍。 这种问题在使用Cython编译后，这种问题暴露的更加明显。 所以如果有使用Cython编译复杂结构的模块时，一定要理清楚导入的逻辑，推荐使用import，尽量节制使用from...import 当然如果结构没那么复杂，可以考虑给模块命名不一样。 函数的参数问题在使用Cython编译后，有的函数被调用时，会爆出一个无参数的TypeError： 1func() takes no keyword arguments 在Bottle框架(一个Web框架)的issue中有人也遇到这种问题。 通过这里给出的方法我们对报出Error的方法进行修改。 例如：1234# 原来def sum(a,b): pass# 修改后def sum(a=None, b=None): pass 这样可以将问题解决。 这个问题在Cython的issue中也有提到。 相关的知识在Python的文档解析参数和生成值中也有部分介绍。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FlaskAdmin相关用法]]></title>
    <url>%2F2017%2F08%2F13%2FFlaskAdmin%E7%9B%B8%E5%85%B3%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[背景之前项目开发的时间不是十分充裕，对项目中管理员身份用户的部分业务直接使用了FlaskAdmin插件进行开发。由于当初没有针对FlaskAdmin做相关设计，导致后期测试时，大部分Bug出现在这一模块。于是，就加深以下对FlaskAdmin插件的一些额外的使用方法。 部分用法介绍基础模型FlaskAdmin的的视图模型是直接与对应的数据库表同步的。与数据库模型对应关系建立十分简单。如果我们使用FlaskAdmin默认的视图模型。直接如下即可建立一个简单的页面。 12345678from flask import Flaskfrom flask_admin import Adminfrom flask_admin.contrib.sqla import ModelViewfrom webapp.models import db, Userapp = Flask(__name__)app.config.... # app.相关配置，DB等admin = Admin(app)admin.add_view(ModelView(User, db.session)) 此时生成的界面如下： 模型进阶我们从上边的图可以看到： 全是英文显示，对用户有很大困扰。 所有的数据列都显示了，有的数据列可能不是我们需要的。 在每列左边的操作区，可以修改，删除等操作，我们可能只需要让用户保留一部分功能。如:只能修改。 为了自定义对应模型的界面，我们可以自定义相关的信息。所以我们自定义一个类并继承ModelView，就可以实现相关的操作。首先我们给出修改后的界面。 1.首先我们中文问题，我们使用了Flask的插件Flask-Bable和Flask-BabelEx，在配置中我们可以使用如下语句： 1BABEL_DEFAULT_LOCALE = 'zh_CN' 然后就解决了界面上大部分的中文，但是表头不是中文。所以我们还要在FlaskAdmin中进行表头的配置。 12345678column_labels = &#123; 'id': u'用户ID', 'username': u'用户名', 'password': u'密码', 'name': u'姓名', 'grade': u'年级', 'emp_no': u'工号'&#125; 这样就完成了中文的翻译。 2.介绍FlaskAdmin的一些配置: 12345678page_size= 10 # 每页显示几条can_create=True # 可以创建数据 False can_delete=True # 可以删除数据 Falsecan_edit=True # 可以编辑数据 Falsecan_view_details=True # 可以查看详情 Falsecolumn_searchable_list=['列名'] # 可以搜索的列名form_exclude_columns=['列名'] # 不显示的列 高级功能1.我们在对Admin进行操作时，对于某些字段我们需要进行限制，比如字段校验，进行一些特殊的限制等。 这里我们可以用自定义的校验器。我们以一个例子展示。 我们需要让用户无法修改admin用户的数据。 在用户表的视图下： 12345678910111213141516# 自定义的校验器def user_validator(form, field): if form._obj is not None: user_id = form._obj.id # 调用user表的方法，通过用户名得到用户信息 user = User.get_user_info(user_id=user_id) if user.username == 'admin': if field.data != 'admin': raise ValidationError(u"admin为最高权限用户，不允许修改")# FlaskAdmin的属性 form_argsform_args = &#123; "username":&#123; 'label': u'用户', 'validators': [DataRequired(), user_validator] &#125;&#125; 这样，我们就完成了对用户名为’admin’的用户无法修改的限制。在程序里，校验器的form属性中的_obj可以获取原始数据库中的数据，而不是当前form的数据。这样就避免了用户直接修改用户名。 2.对于基础的限制，我们还可以继承ModelView中的on_model_change()方法。 on_model_change()是在一个模型创建之前或者修改更新之前进行的操作，所以也可以加一些相关的限制。参数有：form： 将要更新或者创建模型的Form表单model： 即将被创建或者更新的模型is_created： 是不是新建的模型。 True/ False 我们同样给出一个示例： 123def on_model_change(self, form, model, is_created): if 'user' not in [role.role_name for role in model.roles]: raise ValidationError(u'user角色是必须的。') 上边一个简单的例子，完成了在创建新的用户时，必须给用户加上一个user的角色的功能。图如下： 3.同样类似的方法还有after_model_change、on_model_delete、after_model_delete等方法。具体的使用方法我们可以在FlaskAdmin的API上找到相关介绍。 其他操作1.修改FlaskAdmin主页面 默认的主页面是空白的，当然不好看，我们可以在初始化admin的时候自定义主页。如下： 12345admin = Admin(index_view=AdminIndexView( name==u'数据管理', template='MyAdmin/welcome.html', url='/admin',), template_mode='bootstrap3') 其中template对应的html文件是我们自己写的。可以继承来自Admin的源码中的template进行改写。 现在的首页如下： 2.结合权限管理。 对于Admin的界面，我们需要对访问其的权限进行限制，我们可以结合Flask的另外一个插件Flask-Login进行实现。 在我们自定义的ModeView中。 定义方法is_accessible() 如下： 1234def is_accessible(self): if current_user.is_authenticated and current_user.username == "admin": return True return False 这样的话如果用户没有登录，且不属于’admin’用户的话，就不会进入到该视图模型下面。]]></content>
      <categories>
        <category>Flask</category>
      </categories>
      <tags>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我学算法之寻找缺失的整数]]></title>
    <url>%2F2017%2F08%2F09%2F%E6%88%91%E5%AD%A6%E7%AE%97%E6%B3%95%E4%B9%8B%E5%AF%BB%E6%89%BE%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[有关数组里需找数字的算法题目 一个无序数组里有99个不重复正整数，范围从1到100，唯独缺少一个整数。如何找出这个缺失的整数？ 解决办法一： 构建一个字典，以1-100为key，初始value均为0. 遍历原来数组，读到一个数，就将其对应的value设置为1. 遍历字典，得到value为0的key。就是数组中缺失的数字 代码实现： 12345678910111213def check(my_list): # 初始化字典 my_dict = &#123;&#125; for i in range(100): my_dict.update(&#123;i + 1: 0&#125;) # 遍历数组，并操作字典 for i in my_list: my_dict[i] = 1 # 遍历字典得到缺失值。 for i in range(100): if my_dict[i + 1] == 0: return i + 1 算法时间复杂度为O(n)， 空间复杂度为O(n) 解决办法二： 先对原数组进行排序。 逐一判断，相邻元素是否为连续。 不连续的话，中间元素的就是我们要找的结果。 如果全部连续，那么缺失的就是1或者100. 代码实现： 123456789101112def sort_check(my_list): # 首先排序 my_list.sort() # 先判断1和100是否存在 if 1 not in my_list: return 1 if 100 not in my_list: return 100 # 寻找缺失的数字 for i in range(len(my_list)-1): if my_list[i+1] - my_list[i] != 1: return my_list[i] + 1 解决办法三： 当前情况下最佳，也最简单。 由于题目要求计算1-100之间的缺失的整数且不重复！ 那么就可以先计算1+…+100的和，再减去数组中的数字 得到的结果就是我们寻找的数字。 代码实现： 1234567def simple_check(my_list): # 计算1-100的和 result = sum([i + 1 for i in range(100)]) # 逐一相减得到最后结果 for i in my_list: result -= i return result 题目： 一个无序数组里有若干个正整数，范围从1到100，其中99个整数都出现了偶数次，只有一个整数出现了奇数次（比如1,1,2,2,3,3,4,5,5），如何找到这个出现奇数次的整数？ 解决办法： 我们知道异或运算时，相同位的结果为0，不同位的结果为1.那么就可以按照这个规则进行处理了。 对数组中的每个数注意异或相加， 因为其他的数字都是偶数次，所以最后的结果都是0 对于唯一出现奇数次的数字，就是最终的结果 代码实现： 12345def check_one_num(my_list): result = 0 for i in my_list: result ^= i return result 题目： 一个无序数组里有若干个正整数，范围从1到100，其中98个整数都出现了偶数次，只有两个整数出现了奇数次（比如1,1,2,2,3,4,5,5），如何找到这个出现奇数次的整数？ 解决思路： 我们依旧可以一句第二道题的思路，但是难点在于存在两个整数出现奇数次。注意到数字的二进制表示是唯一的，所以我们发现这两个缺失的数可以依据某些条件分成两个数组中，遵循分治法的要求。 解决办法： 首先对数组中的所有数字进行异或，最终的结果转换为二进制。 假如转换后的二进制是00000101(就是数字5)那么我们可以选择任意一个1所在的二进制位来分开原数组。 比如我们选择末位，所以可以分开来两部分。而缺失的两个数分别在一部分。 再对分开的数字进行异或，最终可以得到这两个数。 代码实现： 123456789101112131415161718def check_two_num(my_list): result = 0 num1 = 0 num2 = 0 # 先异或出原来数组的结果 for i in my_list: result ^= i # 寻找出我们需要的1 tail = str(bin(result)).rindex('1') flag = str(bin(result))[tail:] # 按照条件分开数组，直接计算出最终结果。 for i in my_list: if str(bin(i)).endswith(flag): num1 ^= i else: num2 ^= i return num1, num2 代码放置与 我的github上 题目来源： 寻找缺失的整数]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python函数参数总结]]></title>
    <url>%2F2017%2F08%2F09%2Fpython%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[参数传递Python中的参数传递存在以下几种情况： 基本定义方式这是最常见的定义方式。 12def foo(arg1, atg2,...) pass 一个函数可以定义任意个参数，参数中间使用,隔开，使用这种定义方式的函数在调用的时候，必须提供所有的参数，并且顺序也要一致。否则就会报错。 提供默认值的参数这种方式就是第一种方式的稍微改进版本。 12def foo(arg1, arg2=2): pass 此时，调用这个函数的时候，可以只传递arg1一个参数，因为arg2存在默认值，接收不到参数时，就是使用默认值。 使用单个星号 *在程序中，有时候我们可能不太清楚有多少个参数，所以可以使用*来传递不确定的参数。 12def foo(\*args): pass 在参数名前边加上*号就是让函数可以接受任意多的位置参数，但是不管传递的参数有多少个，都会存储在一形参名为标识符的tuple中。 使用双星号 **在形参名的前边加上**,参数在函数的内部将会存为形参名为标识符的字典中。并且是以关键字参数为key，位置参数为value的字典。 12def foo(\*\*kwargs): pass 在函数调用的时候，要以foo(arg1=value1, arg2=value2)这种形式调用。这样内部使用的时候可以直接调用args1和arg2。 Tips：函数参数在调用过程中是以上述四中方式优先级依次降低的次序执行解析的。 zip函数这时候理解zip函数中的*就十分简单了。 我们需要多个参数，但是想以list作为参数。就可以使用* 12345678910a = [[1,2,3,4], ['1a', '2a', '3a', '4a']]result = zip(\*a)for i in result: print(i) # output:(1, '1a')(2, '2a')(3, '3a')(4, '4a') 所以我们可以使用zip函数进行矩阵的转换。 12345678a = [[1,2,3], [4,5,6], [7,8,9]]for i in zip(\*a): print(i)# output(1, 4, 7)(2, 5, 8)(3, 6, 9)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker-compose部署web项目]]></title>
    <url>%2F2017%2F08%2F08%2Fdocker-compose%E9%83%A8%E7%BD%B2web%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[需求： 要在docker中运行运行Web项目 需要一个数据库存储 部署简易。 解决：基于docker-compose实现部署项目 当前项目结构 ├── db_proj│ ├── db.sql│ └── Dockerfile├── docker-compose.yml└── web_proj ├── DataPlatformSystem │ ├── manage.py │ ├── README.md │ ├── requirements.txt │ ├── tests │ │ └── __init__.py │ └── webapp │ ├── config.py │ ├── __init__.py └── Dockerfile docker-compose的配置文件内容 db: build: ./db_proj # image: postgres:9.5 environment: - POSTGRES_USER=postgres - POSTGRES_PASSWORD=111111 # - POSTGRES_DB=testDB ports: - &quot;5432:5432&quot; web: build: ./web_proj command: python /app/DataPlatformSystem/manage.py volumes: - /app/DataPlatformSystem ports: - &quot;5000:5000&quot; - &quot;8001:8001&quot; - &quot;9001:9001&quot; links: - db lables: com.dragonteam.des: &quot;数据管理平台&quot; com.dragonteam.department: &quot;DragonTeam&quot; com.dragonteam.release: &quot;v0.5&quot; db_proj下的Dockerfile FROM postgres ENV POSTGRES_DB test COPY db.sql /docker-entrypoint-initdb.d/ web_proj下的Dockerfile FROM ubuntu COPY DataPlatformSystem /app/DataPlatformSystem WORKDIR /app/DataPlatformSystem RUN buildDeps=&apos;python python-pip python-dev python-tk&apos;\ &amp;&amp; cp /etc/apt/sources.list /etc/apt/sources.list.bak \ &amp;&amp; sed -i &apos;s/archive.ubuntu.com/mirrors.ustc.edu.cn/g&apos; /etc/apt/sources.list \ &amp;&amp; apt-get update &amp;&amp; apt-get install --assume-yes apt-utils \ &amp;&amp; apt-get install -y $buildDeps \ &amp;&amp; pip install --upgrade pip \ &amp;&amp; pip install -r /app/DataPlatformSystem/requirements.txt 所遇问题：数据库容器连接问题：如果web应用的容器和数据库服务的容器分离，就要使用links指定关联、 links: - db 那么在web应用中的配置信息中就要使用此配置信息， SQLALCHEMY_DATABASE_URI = &apos;postgresql://postgres:111111@db/test&apos; 其中的db就是links的配置内容。 路径问题：在docker-compose.yml中使用build命令时，指定的路径可以是绝对路径，或者是相对于docker-compose.yml文件的相对路径。 build: /path/to/build/dir 参考资料： Docker从入门到实战 Docker部署Flask项目 使用docker-compose docker-postgres-issue Docker初始化导入数据库文件]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pip can not install MarkupSafe]]></title>
    <url>%2F2017%2F08%2F07%2Fpip-can-t-install-MarkupSafe%2F</url>
    <content type="text"><![CDATA[背景今天早上试用pyecharts时（环境：Python3.6.1），使用pip安装.在安装时报出错误。此错误应该是针对于（MarkupSafe）模块的。如下： 解决问题1、通过traceback可以看到应该是pip命令将控制台的字符串进行编码转换时出现了错误。因为我这是在windows下进行的，所以console上使用的是gbk的编码，但是pip模块却使用utf-8进行解码，所以产生了错误。找到对应的出错位置，我们修改一下对应的代码。找到\lib\site-packages\pip\compat\__init__.py文件定位到第75行： 我们将原来的utf_8修改为gbk. 执行 pip freeze命令，如果存在安装包（MarkupSafe）， 先进行卸载。 重新安装。 发现没有问题。 同样环境在Linux下却不会出现问题，因为Linux的console默认utf-8编码。如图(Konsole)：]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础之迭代器+生成器]]></title>
    <url>%2F2017%2F08%2F06%2FPython%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8-%E7%94%9F%E6%88%90%E5%99%A8%2F</url>
    <content type="text"><![CDATA[迭代器(iterator)简介迭代器是访问集合内元素的一种方式。迭代器对象从集合的第一个元素开始访问，直到所有的元素都被访问一遍后结束。 优点： 对于无法随机访问的数据结构(比如set)而言,迭代器是唯一的访问元素的方式。 迭代器不要求你事先准备好整个迭代过程的所有的元素，它仅仅是在迭代至某一个元素时才计算该元素。在这之前或者之后，元素可以不存在或者被销毁。适合巨大的或者无限的集合。 迭代器提供了一个统一的访问集合的接口。只要实现了iter()方法的对象，就可以使用迭代器进行访问。 缺点 迭代器无法回退，只能向前进行迭代。 迭代器不是线程安全的，在多线程环境中对可变集合使用迭代器是一个危险的操作。 简单使用使用内建函数iter可以从可迭代的对象中获得迭代器。 &gt;&gt;it = iter([1, 2, 3]) &gt;&gt;it.next() 1 &gt;&gt;it.next() 2 上述的it.next()可以使用next(it)替换。 如果迭代到最后一位后，再调用it.next()就会出现StopIteration的异常。但是我们可以通过检测到异常信息，来退出迭代器。 使用迭代器的循环可以避开索引，但有时候我们还是需要索引来进行一些操作的。这时候内建函数enumerate就派上用场咯，它能在iter函数的结果前加上索引，以元组返回，用起来就像这样： &gt;&gt;lst = range(3) &gt;&gt;for idx, ele in enumerate(lst): &gt;&gt; print idx, ele 0 0 1 1 2 2 Tips：使用list的构造方法显式地将迭代器转化为列表、 生成器(Generator)简介生成器是一种用普通函数语法定义的迭代器。它主要依赖于yield关键字，任何包含yield语句的函数都称为生成器。 生成器和函数的主要区别在于函数return a value，生成器yield a value同时标记且记忆point of the yield 以便于在下次调用时从标记点恢复执行。 示例学习创建生成器 我们创建一个函数，用来展开列表的列表的值顺序打印。 In [35]: my_list = [[1, 2], [3, 4], [5]] In [36]: def un_fold(the_list): ...: for _list in the_list: ...: for element in _list: ...: yield element ...: In [37]: list(un_fold(my_list)) Out[37]: [1, 2, 3, 4, 5] 在这里，就是一个生成器，如果我们将yield element换成print element那么就是一个普通的函数。区别就在于，生成器并没有return一个值，而是产生多个值。每次产生一个值(即使用yield语句),函数就被冻结：重新唤醒后，就会延续刚才运行的状态继续。 递归生成器 Demo: In [38]: def flatten(the_list): ...: try: ...: for sublist in the_list: ...: for element in flatten(sublist): ...: yield element ...: except TypeError: ...: yield the_list ...: In [39]: list(flatten([[[1],2], 3,4, [5, [6, 7]], 8])) Out[39]: [1, 2, 3, 4, 5, 6, 7, 8] 在函数flatten被调用时存在两种可能性： 函数被告知展开一个元素时(如一个数字),这时，for循环会出现一个TypeError,生成器会产生一个元素。 如果展开的是一个列表(或者其他迭代器对象)，那么程序就会遍历所有的子列表(一些也可能不是列表)，并对他们调用flatten函数。然后用另一个flatten函数展开子列表中的所有元素。 但是上述的例子由一个问题。如果the_list是一个类似字符串的对象。那么它就是一个序列，不会引发TypeError，但是我们不想对这样的对象进行迭代。所以我们可以在生成器的开始添加一个检查语句。如下 # demo2 In [6]: def flatten(the_list): ...: try: ...: try: the_list + &apos;&apos; ...: except TypeError: pass ...: else: raise TypeError ...: for sublist in the_list: ...: for element in flatten(sublist): ...: yield element ...: except TypeError: ...: yield the_list ...: In [7]: list(flatten([&apos;foo&apos;, [&apos;bar&apos;, [&apos;baz&apos;]]])) Out[7]: [&apos;foo&apos;, &apos;bar&apos;, &apos;baz&apos;] 通用生成器 当生成器被调用时，在函数体的代码不会被执行，而会返回一个迭代器。每次请求一个值，就会执行生成器的代码，直到遇到一个yield或者return语句。yield语句意味着应该生成一个值，return语句意味着生成器要停止运行(不在生成任何东西,return语句只有在一个生成器中使用时才能 进行无参数调用). 换句话说，生成器由两部分构成：生成器的函数和生成器的迭代器。生成器的函数是用def定义的，包含yield的部分。生成器的迭代器是这个函数返回的部分。 # demo In [1]: def simple_generator(): ...: yield 1 ...: In [2]: simple_generator Out[2]: &lt;function __main__.simple_generator&gt; In [3]: simple_generator() Out[3]: &lt;generator object simple_generator at 0x7f2b98d66dc0&gt; Tips： 在生成器中返回的迭代器，可以像其他的迭代器一样使用。 生成器方法 send()方法 在外部作用域访问生成器的send()方法就像访问next()方法一样，只不过前者使用一个参数(即要发送的消息—任意对象) 在内部则挂起生成器，yield现在作为表达式而不是语句来用，也就是说，在生成器重新运行时，yield函数返回一个值，也就是外部通过send方法发送的值，如果next方法被使用，那么yield返回None 注意在使用send方法，只有在生成器挂起的时候，才会有意义，否则就要提供更多信息。 demo 说明这种机制In [4]: def repeater(value):…: while True: …: new = (yield value) …: if new is not None:…: value = new…: In [5]: r = repeater(100) In [6]: r.next()Out[6]: 100 In [7]: r.send(101)Out[7]: 101 In [8]: r.send(“Alex”)Out[8]: ‘Alex’ throw方法：用于在生成器内引发一个异常（在yield表达式中） close方法:调用时不需要参数， 用于停止生成器。 使用enumerate函数普通的遍历索引+值 In [5]: seq = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;] In [6]: i = 0 In [7]: for ele in seq: ...: seq[i] = &apos;%d: %s&apos; % (i, seq[i]) ...: i += 1 ...: In [8]: print seq [&apos;0: one&apos;, &apos;1: two&apos;, &apos;2: three&apos;] 使用enumerate后 In [9]: seq = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;] In [10]: for i, ele in enumerate(seq): ...: seq[i] = &apos;%d: %s&apos; % (i, seq[i]) ...: In [11]: print seq [&apos;0: one&apos;, &apos;1: two&apos;, &apos;2: three&apos;] 更加pythonic的写法 In [12]: seq = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;] In [13]: print [&apos;%d: %s&apos; % (i, ele) for i, ele in enumerate(seq)] [&apos;0: one&apos;, &apos;1: two&apos;, &apos;2: three&apos;]]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于BBB开发板的温度检测和邮件自发送]]></title>
    <url>%2F2017%2F08%2F06%2F%E5%9F%BA%E4%BA%8EBBB%E5%BC%80%E5%8F%91%E6%9D%BF%E7%9A%84%E6%B8%A9%E5%BA%A6%E6%A3%80%E6%B5%8B%E5%92%8C%E9%82%AE%E4%BB%B6%E8%87%AA%E5%8F%91%E9%80%81%2F</url>
    <content type="text"><![CDATA[背景机房里的空调是不能关闭的，但不可避免出现各种问题。于是想通过检测室内的温度，达到某一界限时来向管理员发送通知邮件。 所用介质 1.BeagleBoneBlack开发板2.温度传感器18b203.qq邮箱 搭建过程连接开发板以数据线连接电脑USB到开发板的USB上，开机 配置BBB开发板（将温度传感器注册到开发板上）此处的教程源自One-wire DS1820 thermometer with BeagleBone Black &amp; libmicrohttpd 1.加载驱动文件（自己理解的）在开发板root目录下新建一个18b20的文件夹编辑BB-W1-00A0.dts文件 /dts-v1/; /plugin/; / { compatible = &quot;ti,beaglebone&quot;, &quot;ti,beaglebone-black&quot;; part-number = &quot;BB-W1&quot;; version = &quot;00A0&quot;; /* state the resources this cape uses */ exclusive-use = /* the pin header uses */ &quot;P9.22&quot;, /* the hardware IP uses */ &quot;gpio0_2&quot;; fragment@0 { target = &lt;&amp;am33xx_pinmux&gt;; __overlay__ { dallas_w1_pins:pinmux_dallas_w1_pins { pinctrl-single,pins = &lt; 0x150 0x37 &gt;; }; }; }; fragment@1 { target = &lt;&amp;ocp&gt;; __overlay__ { onewire@0 { compatible = &quot;w1-gpio&quot;; pinctrl-names = &quot;default&quot;; pinctrl-0 = &lt;&amp;dallas_w1_pins&gt;; status = &quot;okay&quot;; gpios = &lt;&amp;gpio1 2 0&gt;; }; }; }; }; 2.编译dts文件 键入命令： dtc -O dtb -o BB-W1-00A0.dtbo -b 0 -@ BB-W1-00A0.dts 3.加入到配置文件中 cp BB-W1-00A0.dtbo /lib/firmware/ echo BB-W1:00A0 &gt; /sys/devices/bone_capemgr.9/slots 此时你可以验证是否写入成功 cat /sys/bus/w1/devices/DEVICE_ID/w1_slave 编写源代码文件# -*- coding:utf-8 -*- import Adafruit_BBIO.GPIO as GPIO # 导入相关库文件 import time from sendMail import * GPIO.setup(&quot;P9_14&quot;, GPIO.OUT) flag=0 def read_temp_raw(): f = open(&quot;/sys/bus/w1/devices/28-04146829edff/w1_slave&quot;) lines = f.read() f.close() return lines def read_temp(): lines = read_temp_raw() secondline = lines.split(&quot;\n&quot;)[1] temperaturedata = secondline.split(&quot; &quot;)[9] temperature = float(temperaturedata[2:]) temperature = temperature / 1000 return temperature # 以一个死循环让程序持续运行，检测温度值，并发送警告邮件 while True: time.sleep(1) # 每个一秒获得一次温度值 print(read_temp()) if (read_temp() &gt; 30) &amp; (flag==0): #当 温度大于30度，并且是 send(read_temp()) print &quot;hello&quot; flag = flag+1 # GPIO.output(&quot;P9_14&quot;, GPIO.HIGH) elif (read_temp() &lt; 30) : flag= 0 配置邮件自动发送源码如下 # -*- coding: UTF-8 -*- import sys, os, re, urllib, urlparse import smtplib import traceback from email.mime.text import MIMEText from email.mime.multipart import MIMEMultipart def sendmail(subject,msg,toaddrs,fromaddr,smtpaddr,password): mail_msg = MIMEMultipart() if not isinstance(subject,unicode): subject = unicode(subject, &apos;utf-8&apos;) mail_msg[&apos;Subject&apos;] = subject mail_msg[&apos;From&apos;] = &apos;your@qq.com&apos; #此处最好填入邮箱地址，否则会被拦截 mail_msg[&apos;To&apos;] = &apos;,&apos;.join(toaddrs) mail_msg.attach(MIMEText(msg, &apos;html&apos;, &apos;utf-8&apos;)) try: s = smtplib.SMTP() s.connect(smtpaddr) #连接smtp服务器 s.ehlo() s.starttls() s.login(fromaddr,password) #登录邮箱 s.sendmail(fromaddr, toaddrs, mail_msg.as_string()) #发送邮件 s.quit() except Exception,e: print &quot;Error: unable to send email&quot; print traceback.format_exc() def send(read_temp): fromaddr = &quot;your@qq.com&quot; smtpaddr = &quot;smtp.qq.com&quot; toaddrs = [&quot;others@qq.com&quot;] subject = &quot;老师，请注意&quot; password = &quot;your password&quot; msg = &quot;你好，老师！当前温度已经达到&quot;+ str(read_temp) +&quot;度&quot; sendmail(subject,msg,toaddrs,fromaddr,smtpaddr,password) 上述代码中的stmp的starttls方法，有参考python-smtplib. 到此时基本配置已经完成。 在这里的自发送代码十分简单，想要达到自己的需求还需要加以更改。]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[archLinux初识]]></title>
    <url>%2F2017%2F08%2F06%2FarchLinux%E5%88%9D%E8%AF%86%2F</url>
    <content type="text"><![CDATA[##Arch-Linux 配置小记（一） ####一、Arch-Linux简介 #####1.简介&#160;&#160;&#160;&#160;Arch Linux是朝向轻量（lightweight）以及简单（simple）的Linux发行版。其中“简单”（Simplicity）被定义为“避免不必要或复杂的修改”，也就是说，是由开发者角度定义，而非用户角度思考。 因此，受到了许多开发者的喜爱。&#160;&#160;&#160;&#160;作为小白的我，本着对技术的好奇心。也学习一下它的简单玩法。本文纯小白文。欢迎阅读….. #####2.环境&#160;&#160;&#160;&#160;kernel：基于Arch——linux archlinux-2016.09.03-dual.iso&#160;&#160;&#160;&#160;环境：VMware Workstation12 ####二、配置过程记录 #####1.磁盘分区&#160;&#160;&#160;&#160;与其他发行版本的linux的分区不同，Arch的磁盘分区采用纯命令行的操作（包括以后的安装过程）。参阅Arch Wiki)里的相关内容。&#160;&#160;&#160;&#160;这里我们以gdisk(GPT下的fdisk)来进行磁盘分区。&#160;&#160;&#160;&#160;在VM里创建了虚拟机后，开启虚拟机，进入了命令行，此时可以查看当前的分区内容，命令： fdisk -l 此时，可以看到系统的主分区，一般为sda(sdx)。 开始进行分区： 命令： gdisk /dev/sda 进入交互模式： Command（？ for help）: 此时输入n可以开始添加分区，逐次选择分区号，起始扇区，终止扇区和文件系统类型（hex code）。 以分区1：boot，分区2：swap，分区3：根分区，分区4：home。eg：boot分区&#160;&#160;&#160;&#160;(1).分区的分区号默认为1 （boot）&#160;&#160;&#160;&#160;(2).起始扇区选择默认&#160;&#160;&#160;&#160;(3).终止扇区设置为”+300M”,表示大小为300M&#160;&#160;&#160;&#160;(4).hex code选默认（8300）表示为”Linux File System”,如果是swaq分区时则要设置为(8200)表示为swap分区 依次设置完毕后，在交互模式下键入 p 可以查看分区的详细信息，确认后可以键入 w 将分区信息写入磁盘。设置完毕后 Ctrl+c 退出交互模式，回到命令行，首先我们要将boot分区的格式设置为EFI System， 可以使用命令： parted /dev/sda (parted) set 1 boot on 分区完成之后，可以开始下一步 #####2.格式化并挂载磁盘上一步我们完成了分区，sda1~4 分别对应boot,swap,/根目录,home。首先格式化一般的存储目录。 命令： mkfs -t ext4 /dev/sda1 mkfs -t ext4 /dev/sda3 mkfs -t ext4 /dev/sda4 对于交换分区使用mkswqp命令设置格式 mkswap /dev/sda2 设置完毕之后，我们将分区挂载到文件系统上，命令： mount /dev/sda3 /mnt mount /dev/sda1 /mnt/boot mount /dev/sda4 /mnt/home swapon /dev/sda2 其中挂载swap分区的命令有点不同，另外，在挂载之前应先创建好相关的目录，命令： cd /mnt mkdir boot mkdir home 此时挂载完毕。 #####3.在挂载点安装arch此时我们使用pacstrap命令从网上安装基础包和基础开发包，在这一步之前，由于软件源的原因，我们要想完成的速度快，需要更改源。 vi /etc/pacman.d/mirrorslist 将其他地区的源删除，保留中国地区的，建议使用阿里云或者163的源在最前面。 好了开始安装，命令： pacstrap /mnt base base-devel 等待一段时间（30m）左右，即可安装完毕。此时我们要首先设置硬件启动时自动挂载分区，否则进入系统。 命令： genfstab -p /mnt &gt;&gt; /mnt/etc/fstab fstab文件的作用就是，启动时自动挂载磁盘分区，并检测交换分区（swap） #####4.安装引导bootloader系统安装完毕之后，会需要引导来进入操作系统，常见的引导有grup和syslinux,此处我们选择Syslinux。它的相关配置可以查阅 Syslinux Wiki 首先安装syslinux， 命令： pacstrap /mnt syslinux 自动配置syslinux， 命令: syslinux-install_update -i -a -c /mnt 安装完成后，键入命令：* arch-chroot /mnt 进行配置语言、时区等，其中选择语言时需要修改文件 /etc/locale.gen 建议选择英文，避免命令行乱码。 locale-gen echo LANG=&quot;en_US.UTF-8&quot; &gt; /etc/locale.conf ln -s /usr/share/zoneinfo/Asia/Shahai /etc/localtime 然后需要修改syslinux的配置信息，在/boot/syslinux/syslinux.cfg文件中有一些xxx.c32模块，需要把对应的/usr/lib/syslinux/bios/XXX.c32复制到/boot/syslinux/目录下。 主要应该有四个menu.c32、vesamenu.c32、 reboot.c32、 hdt.c32。 在运行命令： extlinux --install /boot/syslinux 此时bootloder安装完毕，此后需要增加一个启动系统的指令 即gptmbr.bin, 命令： dd conv=notrunc bs=440 count=1 if=/usr/lib/syslinux/bios/gptmbr.bin of=/dev/sda 最后，初始化磁盘环境， 命令： mkinitpio -p linux 退出chroot， 命令：exit。取消挂载，并重启，命令： umount -R /mnt swapoff /dev/sda2 重启后就可以通过syslinux引导进入arch-linux的系统了，此时的用户为root，不需要密码。当前系统只有tty(即黑窗口),并无桌面环境。 好啦，第一次先进行这么多， 下一次再对我们的arch-linux进行进一步完善。呜啦啦啦未完待续……..]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构之单链表~]]></title>
    <url>%2F2017%2F08%2F02%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8D%95%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[简介：线性表实现的基本需要： 能够找到表中的首元素（无论直接或间接，通常很容易做到） 从表里的任一个元素出发，可以找到它之后的下一个元素 实现线性表的一种方式是基于链接结构，用链接显式地表示元素之间的顺序关联。基于链接技术实现的线性表称为链接表或链表 而链表有存在单向链表和双向链表，今天我们先介绍以下单向链表(单链表) 链表的单元是节点Node 每个结点（对象）有自己的标识（下面也常直接称其为链接） 结点之间通过结点链接建立起顺序联系 给表的最后一个结点（表尾结点）的链接域设置一个不会作为结点对象标识的值（Python 里自然应该用 None），称为空链接 简单的节点实现代码：class Node(object): def __init__(self, x, nxt): self.val = x self.next = nxt 对单链表的基本操作：1.创建空链表:对于链表而言只需要将表头变量设置为空链接 在Python中我们将其设置为None即可 2.删除链表:丢弃表的所有节点 在python中我们只需要简单的将表指针设为None，就丢掉了整个链表的所有节点，Python的存储管理系统会自动回收掉不用的存储。 3.判断链表是否为空: 将表头变量的值与空链接进行比较 在Python中我们只需要检查其值是否为None即可 4.判断链表是否满 链表不会满， 除非存储空间全部用完 5.首端加入元素 1）创建一个新结点存入数据2）把原链表首节点的连接存入新结点的链接域3) 修改表头变量使之引用新结点 6.尾端加入元素 1) 创建一个新结点存入数据2) 表空时直接让表头变量引用这个新结点并结束，否则找到表尾结点3) 令表尾结点的链接域引用这一新结点，并将新结点的链接域设置为空链接 7.定位加入元素 1) 找到新结点加入位置的前一结点，不存在时结束2) 创建新结点存入数据3) 修改前一结点和新结点的链接域将结点连入 8.首端删除元素 直接修改表头指针，使之引用当时表头结点的下一个结点。Python 系统里会自动回收无用对象的存储块，下同 9.尾端删除元素 找到倒数第二个结点，将其链接域设置为空链接 10.定位删除元素 找到要删除元素所在结点的前一结点，修改它的链接域将要求删除的结点从表中去掉 代码实现：单链表# 单向链表 class SinglyLinkedList(object): def __init__(self): self.head = None # 判空只需要判断指向的下一个节点是否为None def is_empty(self): return self.head is None # 链表首端加入新元素 def prepend(self, element): self.head = Node(element, self.head) # 尾端加入新元素 def append(self, element): # 判断是否为空链表, 是就直接添加 if self.head is None: self.head = Node(element, None) return # 链表不为空, 遍历得到表里最后一个节点, 然后用这个节点的next域记录新结点的链接 p = self.head while p.next is not None: p = p.next p.next = Node(element, None) # 首端弹出元素 def pop(self): if self.head is None: raise ValueError value = self.head.val self.head = self.head.next return value # 弹出尾端元素 def pop_last(self): # 首先判断是否为空链表 if self.head is None: raise ValueError p = self.head # 如果链表只有一个元素 if p.next is None: value = p.val self.head = None return value # 遍历链表 直到找到最后一个节点, 将前一个节点的next置为None while p.next.next is not None: p = p.next value = p.next.val p.next = None return value # 查找元素 def find(self, element): p = self.head while p is not None: if element == p.val: return p.next.val p = p.next return None # 打印出所有元素 def print_all(self): p = self.head while p is not None: print(p.val, end=&quot;&quot;) p = p.next print(&quot;&quot;) 带有尾结点的单链表# 带尾结点引用的单链表 尾结点引用---&gt;即指向最后一个节点 # 较之上一个实现, 有效的解决了尾端插入的效率问题 class SinglyLinkedListWithRearReference(SinglyLinkedList): def __init__(self): SinglyLinkedList.__init__(self) self.rear = None # 首端加入新元素 def prepend(self, element): # 如果为空列表, 就将将元素置为第一个,并将尾节点引用指向当前节点 self.head = Node(element, self.head) if self.rear is None: self.rear = self.head # 尾端加入新元素 def append(self, element): if self.head is None: # 直接调用首端加入, 对于第一个元素, 加入都是一致的 self.prepend(element) else: # 尾端加入新的元素时, 将尾结点引用指向当前新加入的节点 self.rear.next = Node(element, None) self.rear = self.rear.next # 从首端删除元素 def pop(self): if self.head is None: raise ValueError value = self.head.val # 如果尾结点引用指向了头结点, 那么说明 当前链表只有一个元素节点, 删除之后需要将尾结点引用置为None if self.rear is self.head: self.rear = None # 将链表的头指向下一个元素节点 self.head = self.head.next return value # 从尾端删除元素 def pop_last(self): if self.head is None: raise ValueError val = self.rear.val p = self.head while p.next.val != val: p = p.next p.next = None self.rear = p 循环单链表# 循环单链表 不必要使用单链表为基类 class CircularSinglyLinkedList(object): def __init__(self): self.rear = None # 判断是否为空 def is_empty(self): return self.rear is None # 首端加入新元素 def prepend(self, element): p = Node(element, None) # 如果是空链表，就要建立初始的循环链接， 即自己链接自己 if self.rear is None: p.next = p self.rear = p # 链表不空，就要链接在尾结点之后， 就是首结点 else: p.next = self.rear.next # 先将原来的首结点链接在自己的后边 self.rear.next = p # 自己成为首结点 # 尾端加入新元素 def append(self, element): # 直接调用之前的加入操作 self.prepend(element) # 将尾节点置换为新加入的结点 self.rear = self.rear.next # 删除首端元素 def pop(self): # 首先判断是否为空列表 if self.rear is None: raise ValueError p = self.rear.next # 如果尾节点指向自己，说明只有一个结点， 弹出结点之后 将尾节点置空 if self.rear is p: self.rear = None # 正常情况下，删除首结点，并将首结点置为原来首结点的下一个 else: self.rear.next = p.next return p.val # 删除尾端元素 def pop_last(self): # 首先判断是否为空列表 if self.rear is None: raise ValueError p = self.rear.next if p is self.rear: self.rear = None return p.val while p.next is not self.rear: p = p.next p.next = self.rear.next self.rear = p return p.val # 遍历所有结点 def print_all(self): p = self.rear.next while True: print(p.val, end=&quot;&quot;) if p is self.rear: print(&quot;&quot;) break p = p.next 对于单链表的一些操作：from data_structure.link_list.singly_linked_list import SinglyLinkedList # 反序链表 def reverse_by_singly(my_list): &quot;&quot;&quot; 使用修改链接关系： 1如果一直向首端添加结点，最先进去的就会在尾结点 2一直从首端取元素，最后得到的时尾结点。 这样就可以实现反转算法了 :param my_list: 被操作的链表 :return: 无 &quot;&quot;&quot; p = None while my_list.head is not None: q = my_list.head my_list.head = q.next q.next = p p = q my_list.head = p # 基于移动元素的单链表排序 def sort_linked_list_by_move_value(my_list): &quot;&quot;&quot; 为了有效实现，算法只能从头到尾方向检查和处理。 每次拿出一个元素，在已排序的序列中找到正确位置插入 :param my_list: 被操作的链表 :return: 无 &quot;&quot;&quot; if my_list.head is None: return crt = my_list.head.next # 计算从首结点之后开始，即首结点已排序完毕 while crt is not None: x = crt.val p = my_list.head # 从原链表的首结点开始进行比较，存在如下情况 # 1. 当前结点的值大于已排序完毕的结点，跳过 while p is not crt and p.val &lt;= x: p = p.next # 2. 当前结点的值小于已排序完毕的结点， 交换元素位置 while p is not crt: x, p.val = p.val, x p = p.next crt.val = x crt = crt.next # 基于调整链接关系实现排序工作 def sort_linked_list_by_change_relation(my_list): &quot;&quot;&quot; 基本处理模式与移动元素类似. 但是这里不在结点之间移动表元素，而是把被处理的结点取下来接到正确的位置上。 :param my_list: 被操作的链表 :return: 无 &quot;&quot;&quot; # 判断链表是否为空 if my_list.head is None: return # 初始 已排序的段只有一个结点 last = my_list.head # 表示已排序段的尾结点 crt = last.next # 待排序段的首结点 # 顺序链表的结点，每次处理一个结点 while crt is not None: # 设置扫描指针的初始值 p = my_list.head # 已排序，并且比较完毕的段 q = None # 已排序但为比较完毕的段 while p is not crt and p.val &lt;= crt.val: # 顺序更新两个扫描指针 q = p p = p.next # 当 p 是 crt 时 不需要修改链接，设置last到下一个结点crt if p is crt: last = crt else: # 取出当前结点 last.next = crt.next # 接好后置链接 crt.next = p if q is None: # 作为新的首结点 my_list.head = crt else: # 接在表中间 q.next = crt # crt 指向last的下一个结点 crt = last.next 经典的Josephus问题(使用循环单链表解决)：&quot;&quot;&quot; @description: 经典问题 Josephus问题 @author: merleLK @contact: merle.liukun@gmail.com @date: 17-8-2 @detail: 问题描述： 设有n个人围坐一圈，现在从第k个人开始报数，报到第m的人退出。 然后继续报数，直至所有人退出。输出出列人顺序编号。 &quot;&quot;&quot; from data_structure.link_list.singly_linked_list import CircularSinglyLinkedList # 基于list和固定大小的数组 def josephus_list(n, k, m): &quot;&quot;&quot; 1.建立一个包含n个人（编号）的list 2.找到k个人， 从那里开始 处理过程中，把对应的表元素修改为0表示人已经退出 3.反复操作： 数m个（在席）人 把表示第m个人的元素修改为0 Tips: 数到list最后元素之后转到下标为0的元素继续 :param n: 列表的长度 :param k: 开始位置 :param m: 退出条件 :return: 无 &quot;&quot;&quot; people = list(range(1, n + 1)) print(people) i = k - 1 # 开始位置的下标 for num in range(n): count = 0 # 报数编号 # 一次循环最多到m， 此时就会把最后一个人踢出 while count &lt; m: if people[i] &gt; 0: count += 1 if count == m: print(people[i], end=&quot;&quot;) people[i] = 0 i = (i + 1) % n # 遍历到最后一个位置就会从首位再次开始 print(&quot;,&quot; if num &lt; n - 1 else &quot;\n&quot;, end=&quot;&quot;) def josephus_list_pop(n, k, m): &quot;&quot;&quot; 1.算出应该退出的元素之后, 将其从表中删除 2.直至表长度为0的时候结束 复杂度： O(n^2) :param n: 列表的长度 :param k: 开始位置 :param m: 退出条件 :return: 无 &quot;&quot;&quot; people = list(range(1, n + 1)) i = k - 1 for num in range(n, 0, -1): i = (i + int(m) - 1) % num print(people.pop(i), end=&quot;&quot;) print(&quot;,&quot; if num &gt; 1 else &quot;\n&quot;, end=&quot;&quot;) class JosephusLinkedList(CircularSinglyLinkedList): &quot;&quot;&quot; 1.从形式看，循环单链表很好地表现了围坐一圈的人 2.顺序的数人头，很好的符合了循环表中沿着next链扫描 3.某人退出之后，删除相应结点，之后可以继续沿着原来的方向数人头 算法复杂度 O(m*n) &quot;&quot;&quot; def __init__(self, n, k, m): CircularSinglyLinkedList.__init__(self) # 创建包含n个元素的循环链表 for i in range(n): self.append(i + 1) # 将初始结点移动到k处 self.turn(k - 1) # 循环弹出第m个元素直到链表为空 while not self.is_empty(): self.turn(m - 1) print(self.pop(), end=&quot;&quot;) print(&quot;,&quot; if self.rear is not None else &quot;\n&quot;, end=&quot;&quot;) # 将循环表对象的rear指针沿着next移动了m步 def turn(self, m): for i in range(m): self.rear = self.rear.next if __name__ == &apos;__main__&apos;: josephus_list(10, 2, 7) josephus_list_pop(10, 2, 7) JosephusLinkedList(10, 2, 7) 源代码已经放置于我的github.]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python函数之format]]></title>
    <url>%2F2017%2F07%2F28%2Fpython%E5%87%BD%E6%95%B0%E4%B9%8Bformat%2F</url>
    <content type="text"><![CDATA[python format 函数总结文章基于Python2.7.12进行讲述： &#160;&#160;&#160;&#160;在python中格式化字符串进行输出时，通常会用到format函数。 &#160;&#160;&#160;&#160;介绍一下简单用法： &#160;&#160;&#160;&#160;1.将字符串替换 In [1]: print &apos;{0} {1} {2}&apos;.format(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;) a b c &#160;&#160;&#160;&#160;2.按照参数格式化 In [2]: print &apos;{name} {age}&apos;.format(age=21, name=&apos;lkhardy&apos;) lkhardy 21 &#160;&#160;&#160;&#160;3.限制字符串内的信息范围 In [3]: print &apos;{array[5]}&apos;.format(array=range(10)) 5 In [4]: print &apos;{array[12]}&apos;.format(array=range(10)) -------------------------------------IndexError Traceback (most recent call last) &lt;ipython-input-13-e9cd5827deae&gt; in &lt;module&gt;()----&gt; 1 print &apos;{array[12]}&apos;.format(array=range(10)) IndexError: list index out of range &#160;&#160;&#160;&#160;4.直接调用系统函数 In [14]: print &apos;{attr.__class__}&apos;.format(attr=0) &lt;type &apos;int&apos;&gt; In [15]: print &apos;{attr.__class__}&apos;.format(attr=&quot;d&quot;) &lt;type &apos;str&apos;&gt; &#160;&#160;&#160;&#160;5.转义 In [18]: print &apos;{name!r}&apos;.format(name=u&apos;汉字&apos;) u&apos;\u6c49\u5b57&apos; In [19]: print &apos;{name!r}&apos;.format(name=u&apos;lkhardy&apos;) u&apos;lkhardy&apos; In [20]: print &apos;{name!r}&apos;.format(name=u&apos;1234&apos;) u&apos;1234&apos; &#160;&#160;&#160;&#160;6.识别格式化 In [24]: print &apos;{digit:*^ 10.5f}&apos;.format(digit=1.0/3) * 0.33333* In [25]: print &apos;{digit:*^ 10.5f}&apos;.format(digit=10.0/3) * 3.33333* 未完待续。。。。。。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python的虚拟环境]]></title>
    <url>%2F2017%2F07%2F28%2FPython%E7%9A%84%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[简述：&#160;&#160;&#160;&#160;问题：&#160;&#160;&#160;&#160;我们知道Python的魅力更在于它庞大的第三方库。所以在实际的开发环境中，可能会同时进行多个项目，也许就会出现一个项目是基于python2.x，而另一个项目是基于python3.x的尴尬情况，以及其他很多不方便的情况，比如无法自动生成requirements文件etc。。。。。&#160;&#160;&#160;&#160;Methods：&#160;&#160;&#160;&#160;于是就有virtualenv这个插件很好的解决了这个问题。下面讲解它的基础使用。以及更为方便的一个插件virtualenvwrapper。 使用virtualenv&#160;&#160;&#160;&#160;安装&#160;&#160;&#160;&#160;virtualenv的安装十分简单，使用pip就能很方便的安装： sudo pip install virtualenv &#160;&#160;&#160;&#160;基础操作&#160;&#160;&#160;&#160;1.创建虚拟环境&#160;&#160;&#160;&#160;使用如下命令即可在当前目录下创建一个名为env1的虚拟环境 virtualenv env1 &#160;&#160;&#160;&#160;还可以创建指定解释器版本的虚拟环境 virtualenv -p python2.7 env2.7 #该环境下解释器为python2.7virtualenv -p python3.5 env3.5 #该环境下解释器为python3.5 &#160;&#160;&#160;&#160;如果你的系统里的python已经安装第三方库，你想直接继承过来使用，使用如下命令 virtualenv –system-site-packages env &#160;&#160;&#160;&#160;默认的是不加继承的，或者使用以下命令 virtualenv –no-site-packages env &#160;&#160;&#160;&#160;2.启动和退出虚拟环境&#160;&#160;&#160;&#160;启动，要想启动创建好的虚拟环境，需要到其安装目录(即当前目录下)，输入如下命令： source env1/bin/activate 当命令行头出现(env1)时就表示虚拟环境已经启动。此时我们再次使用pip、setools、easy_install等安装的插件就只会在此虚拟环境之下，不会影响系统内的默认环境、或者其他的虚拟环境。 &#160;&#160;&#160;&#160;退出，要想从当前虚拟环境之下退出，只需执行如下命令即可： deactivate 使用virtualenvwrapper&#160;&#160;&#160;&#160;virtualenv的出现使得项目间的环境使用更加方便和简洁，而virtualenvwrapper是一个基于virtualenv之上的一个工具，它提供了更加方便的虚拟环境管理方式。即统一管理。 &#160;&#160;&#160;&#160;安装 &#160;&#160;&#160;&#160;安装操作仍然十分简单，使用如下命令即可安装此工具： sudo pip install virtualenvwrapper &#160;&#160;&#160;&#160;windows下安装 pip install virtualenvwrapper-win &#160;&#160;&#160;&#160;virtualenvwrapper默认将所有的虚拟环境放在~/.virtualenvs目录下管理，但是也可以修改环境变量WORKON_HOME来指定虚拟环境的保存目录。 &#160;&#160;&#160;&#160;基本操作&#160;&#160;&#160;&#160;1.启动&#160;&#160;&#160;&#160;使用前需要在shell里执行： source /usr/local/bin/virtualenvwrapper.sh 为了方便使用这个命令，我们可以把如下命令加到shell的配置文件中： sudo vim ~/.profile export WORKON_HOME=$HOME/.virtualenvsexport PROJECT_HOME=$HOME/Develsource /usr/local/bin/virtualenvwrapper.sh &#160;&#160;&#160;&#160;2.相关命令&#160;&#160;&#160;&#160;列出已有的虚拟环境，命令如下： workon &#160;&#160;&#160;&#160;创建新的虚拟环境，创建完毕之后会自动切换到当前环境，命令如下： mkvirtualenv env1 &#160;&#160;&#160;&#160;列出当前环境下中所安装的包，命令如下： lssitepackages &#160;&#160;&#160;&#160;切换虚拟环境，命令如下： workon env2 &#160;&#160;&#160;&#160;退出当前环境，命令如下： deactivate &#160;&#160;&#160;&#160;删除虚拟环境，如果该环境正在使用，那么必须先退出该环境，命令如下： rmvirtualenv env1 &#160;&#160;&#160;&#160;显示指定环境的详情，命令如下： showvirtualenv env1 &#160;&#160;&#160;&#160;把指定的目录加入当前使用的环境path中，命令如下： add2virtualenv dir dir &#160;&#160;&#160;&#160;复制一份虚拟环境 cpvirtualenv source dest &#160;&#160;&#160;&#160;还可以在上面我们配置过的目录PROJECT_HOME下创建一个新项目。 mkproject project_name OK，以上就是关于virtualenv和增强工具virtualenvwrapper的简单使用介绍。另外说一点，在windows上使用时会出现一些命令使用的问题，好好搜索哦，本文是基于linux上使用的….呼呼，欢迎大家指正哦。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新博客搬迁计划]]></title>
    <url>%2F2017%2F07%2F27%2F%E6%96%B0%E5%8D%9A%E5%AE%A2%E6%90%AC%E8%BF%81%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[懒人自述很久之前用wordpress搭建一个个人博客。但是后来服务器到期了，决定搬迁一下。 新博客采用hexo搭建,主题使用next。简直完美。 正好趁此机会把之前写的博客好好整理一番。熟悉熟悉自己的技能栈。 开始找工作啦。。。。。。]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>杂项</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js遍历对象的几个方法]]></title>
    <url>%2F2017%2F07%2F26%2Fjs%E9%81%8D%E5%8E%86%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E4%B8%AA%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[有关对象遍历的几个方法。所有继承到Object的对象都会继承到hasOwnProerty()方法，此方法用来检测一个对象是否包含特定的自身属性，其与in运算符不同之处在于，hasOwnProperty方法会忽略掉那些从原型链上继承到的属性。 1.一个简单的例子： 检测对象obj是否含有自身属性’prop’. obj = new Object(); obj.prop = &apos;exists&apos;; function changeO(){ // 将prop属性删除。 obj.newprop = obj.prop; delete obj.prop; } alert(obj.hasOwnProperty(&apos;prop&apos;)); // True changeO(); alert(obj.hasOwnProperty(&apos;prop&apos;)); // False 对于从原型链上继承的属性，hasOwnProperty方法会将其忽略。而in操作符则是将原型链上的属性也涵盖。 alert(obj.hasOwnProperty(&apos;toString&apos;)); // False alert(&apos;toString&apos; in obj); // True 2.遍历一个对象所有的自身属性。忽略掉继承属性。 var buz = { fog: &apos;stack&apos;, name: &apos;hello&apos; }; for (var name in buz) { if (buz.hasOwnProperty(name)) { alert(&quot;this is fog (&quot; + name + &quot;) for sure. Value: &quot; + buz[name]); } else { alert(name); // toString or something else } } 注意： 此例子中for...in循环只会遍历可枚举的属性。 3.处理json对象转为字符串。 我们需要遍历一个json对象。 var s = &apos;{&quot;data&quot;:[{&quot;d1&quot;: &quot;c1&quot;, &quot;d2&quot;: &quot;c2&quot;}]}&apos;; var parsedData = JSON.parse(s); for(var i in parserd_data){ for(var j in parserd_data[i]){ alert(parserd_data[i][j]); console.log(parserd_data[i][j]); for (var k in parserd_data[i][j]){ alert(parserd_data[i][j][k]); } } } 这种方法有些费劲，所以可以定义一个函数进行遍历,虽然函数很长，但是对基本的情况也进行了校验，没有使用那么多的嵌套循环。 function JsonToStr(data){ var resultStr = &quot;&quot;; for (var i in data){ if (data.hasOwnProperty(i)){ if (typeof(data[i]) === &quot;object&quot;){ JsonToStr(data[i]); } else{ if(resultStr === &quot;&quot;){ resultStr = i + &quot;,&quot; + data[i]; } else{ resultStr = resultStr + &quot;,&quot; + i + &quot;,&quot; + data[i]; } } } } return resultStr; } 参考资料： MDN web docs]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScrip基本数据类型的常用操作]]></title>
    <url>%2F2017%2F07%2F25%2FJavaScrip%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[一、背景在日常项目中，发现会经常用到JS基本数据类型相关的一些操作。经常是当场搜索相关的用法。还是不利于自己学习。所以还是记录以下，增加自己的记忆。 二、字符串相关1.移除字符串中某些特定的字符。 1.1使用replace()函数替换 # 去除myStr字符串中的, : ; = &apos;[ ] &apos; + 等符号 var myStr = &quot;123,abc:456;abc=abc[]&quot;; myStr.replace(/[,:;=\[\]]+/g,&apos;&apos;); output: &quot;123abc456abcabc&quot; 1.2使用split()和join()函数 # 去掉冒号: var myString = &quot;12:30:21&quot; var handledString = myString.split(&quot;:&quot;).join(&quot;&quot;) output: &quot;123021&quot; # 去除myStr字符串中的, : ; = &apos;[ ] &apos; + 等符号 var myStr = &quot;123,abc:456;abc=abc[]&quot;; var handledString = my_str.split(/[,:;]/).join(&quot;&quot;) output: &quot;123abc456abc=abc[]&quot; 两中方法都使用了正则表达式进行处理。 2.删除字符串最后一个字符。 2.1使用substring()函数 # 去除字符串中最后一个, var myString = &quot;1,2,3,4,&quot; var handledString = myString.substring(0, s.length-1) output: &quot;1,2,3,4&quot; substring(start, end)函数，经常用于提取一个字符串中下标在[start, end)之间的子字符串。包含start,不包含end。 如果 start 与 end 相等，那么该方法返回的就是一个空串（即长度为 0 的字符串）。 如果 start 比 end 大，那么该方法在提取子串之前会先交换这两个参数。 如果 start 或 end 为负数，那么它将被替换为 0。 3.获取字符串中子字符串。 3.1 使用2.1中的substring()函数，但需要指定下标。 3.2使用substr()函数 var myString = &quot;0123456789&quot; # 获取从第6位开始的所有剩余字符, 下标从0开始 var handledString = myString.substr(5) substr(start, length)函数，用于返回一个从指定位置开始的指定长度的子字符串。 参数说明 start 必须要有，所需字符串的起始位置。 length 可选，返回的字符串中应包含字符的个数 如果start为负数，那么start=str.length+start 如果length为0或者负数，就会返回一个空字符串 如果不指定length参数，则字符串就会一直到str的末尾 4.判断字符串是否在另一个字符串中。 4.1使用indexof()函数 var fullStr = &apos;helloWorld&apos;; if(fulleStr.indexof(&apos;hello&apos;)){ alert(&apos;fullStr has str hello&apos;); } fullStr.indexof(str)函数,用于返回String对象内第一次出现子字符串的字符位置。如果没有找到子字符串就会返回-1 未完待续……………..]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[from-import和import]]></title>
    <url>%2F2017%2F07%2F24%2Ffrom-import%E5%92%8Cimport%2F</url>
    <content type="text"><![CDATA[简介：在使用Python编写项目时，我们经常使用import xx或者from xx import a去导入其他模块或者其他模块中的一些对象和方法，那么这两个语句有什么不一样的呢。在此处，做一下总结，让自己对它们的原理进行一些了解。 方法：Python提供了三种方法引入外部模块，import语句、from...import...和__import__函数。我们最为常用的是前两者。对于第三种方式，它与import语句类似，只是前者显式的将模块的名称作为字符串传递并赋值给命名空间的变量。 注意事项： 尽量优先使用import语句，如import a.B，可以访问B 有节制的使用from a import B形式，但是这样也可以直接访问B 避免使用from a import *形式，这样会污染命名空间，并且导入了哪些模块也不清晰。 import的原理Python的import机制，在Python初始化运行环境时候会预先加载一批内建模块到内存中，这些模块相关的信息存放在了sys.modules中，用户导入sys模块后使用sys.modules.items()可以显示所有预加载模块的相关信息。 当加载一个模块时，Python解释器做了以下一些事情： 在sys.modules中进行搜索，如果该模块已经存在，就将该模块导入到当前局部命名空间。加载就结束了。 如果在sys.modules中找不到该模块的名称，则为需要导入的模块创建一个字典对象，并将该对象信息插入到sys.modules中。 加载前确认是否需要对模块对应的文件进行编译，如果需要编译就要进行编译。 执行动态加载，在当前模块中的命名空间中执行编译后的字节码文件，并将其中所有的对象放入到模块对应的字典中。 无节制使用from…import…带来的问题命名空间冲突例子：有如下三个文件 在模块a和模块b中都定义了add()函数。那么我们在test文件中使用from...import...的形式导入add时，最终起作用的是哪一个呢？ # filename a.py def add(): print(&quot;add in module A&quot;) # filename b.py def add(): print(&quot;add in module B&quot;) # filename test.py from a import add from b import add if __name__ == &apos;__main__&apos;: add() 运行test.py之后，我们得到输出： &quot;add in module B&quot; 也就是说在这里起作用的是最近导入的add(),它完全覆盖了当前命名空间中之前导入的模块a中的add().所以在大型的项目中，我们所包含的包和模块数目非常多，因此使用from...import...语句将会大大增加了命名空间冲突的概率，很大可能会导致出现无法预料的错误和问题。所有有必要有节制的使用from...import...语句。 当然在以下的一些情况中可以考虑使用from...import...语句 当只需要导入部分属性或者方法时。 模块中的某些属性和方法使用频率很高导致使用a.B这种形式进行访问过于烦琐时。 某模块的文档明确说明需要使用from...import形式，能后更为简单和便利时。如使用from io.drivers import zip要比使用import iodrivers.zip更加方便。 循环嵌套导入问题例子： # filename c1.py from c2 import g def x(): pass # filename c2.py from c1 import x def g(): pass 像上边的两个文件，无论运行哪一个，都会报出ImportError的错误。解析如下： 在执行c1.py的加载过程的时候需要创建新的模块对象c1然后执行c1.py所对应的字节码，此时遇到语句from c2 import g,而此时c2在sys.modules中并不存在。然后就会创建与c2对应的模块对象并执行c2.py， 而在执行c2.py时候，又遇到from c1 import x语句，此时的c1对象虽然已经存在，但是初始化的过程并未完成，所以不存在x对象，所以c2也无法初始化完成。 再次执行c1.py时，就会报出ImportError: cannot import name g异常。 而使用import可以解决这个问题。修改文件如下： # filename c1.py import c2 def x(): pass # filename c2.py import c1 def g(): pass 此时就可以运行这两个文件了。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[collections模块之namedtuple使用]]></title>
    <url>%2F2017%2F07%2F23%2Fcollections%E6%A8%A1%E5%9D%97%E4%B9%8Bnamedtuple%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[简介在python中tuple是一个不可变的且轻量型的集合对象，但是使用时，我们只能通过索引的方式去获取元组中的元素。不太方便，并且容易出错。而在collections模块中namedtuple对象则给出了一个更加便捷的操作方式，即给元组中的元素命名。它可以被用作类似于struct或其他常见record types，但它们是不可变的。 简单使用1.创建namedtuple form collections import namedtuple Point = namedtuple(&apos;Point&apos;, &apos;x y&apos;) point1 = Point(1.0, 5.0) point2 = Point(2.5, 1.5) 上例即创建了一个名字为Point的namedtuple对象. 2.namedtuple对象的参数解析 a.示例中的Point是namedtuple的名称。 b.示例中的x y这个字符串中的两个用空格隔开的字符表示这个namedtuple中有两个元素，名为x,y.(避免关键字) c.如果在数据库中读列名作为元素名时可能会出现相同名，程序会报错，那么可以在定义namedtuple时开启自动重命名。如下： Point = namedtuple(‘Point’, ‘x y’， rename=True) 此时命名方式为_indexnumber,下划线+索引号。 调用方式3.1索引方式调用 对于示例中的定义的Point1,可以采用索引方式调用获取其中的值. In [7]: x = point1[0] Out : 1.0 In [10]: y = point1[1] Out : 5.0 3.2元素名方式调用 对于示例中的定义的Point2,可以采用元素名调用获取其中的值. In [12]: x = point2.x Out : 2.5 In [14]: y = point2.y Out : 1.5 总结4.1 你应该使用namedtuple代替那些你认为影响了你代码的易读性的tuple，以便让你的代码更加pythonic. 4.2 此外，你还可以替换那些没有功能函数、只有字段的普通不可变类。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker简单使用]]></title>
    <url>%2F2017%2F07%2F22%2Fdocker%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[简介:Docker是一个开源的引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在笔记本上编译测试通过的容器可以批量地在生产环境中部署，包括VMs（虚拟机）、bare metal、OpenStack 集群和其他的基础应用平台。Docker通常用于如下场景： web应用的自动化打包和发布； 自动化测试和持续集成、发布； 在服务型环境中部署和调整数据库或其他的后台应用； 从头编译或者扩展现有的OpenShift或Cloud Foundry平台来搭建自己的PaaS环境 删除：1.删除container a.单独删除具体某一个容器 ➜ ~ sudo docker rm CONTAINER_ID ➜ ~ sudo docker rm -f 删除运行中的容器 b.删除当前所有容器(已终止运行) ➜ ~ sudo docker rm $(sudo docker ps -a -q) 2.删除image a.删除某个镜像 ➜ ~ sudo docker rmi &lt;image_id&gt; b.删除所有镜像 ➜ ~ sudo docker rmi $(sudo docker images -q) c.删除所有untagged的镜像(就是id为None的镜像) ➜ ~ sudo docker images | grep &quot;^&lt;none&gt;&quot; | awk &quot;{print $3}&quot; 查看：1.查看所有容器 ➜ ~ sudo docker ps -a 2.查看所有正在运行的容器 ➜ ~ sudo docker ps 3.查看镜像 ➜ ~ sudo docker images 运行：1.创建一个container ➜ ~ sudo docker run image_name 2.启动一个container ➜ ~ sudo docker run container_name 3.重命名container ➜ ~ sudo docker rename old_name new_name 4.重启某个容器 ➜ ~ sudo docker restart container_name Tips: docker run 的相关参数说明: --name 指定容器名 -p 指定端口映射 eg 3306:3306 -v 挂载数据卷或者本地目录映射 :ro 挂载为只读 -d 后台持续运行 -i 交互式操作 -t 终端 -rm 容器退出后随之将其删除(与-d 冲突) 停止：1.停止所有正在运行的容器 ➜ ~ sudo docker kill $(docker ps -q) 相关示例：1.使用docker创建postgresql数据库容器 sudo docker search postgres sudo docker pull postgres:9.5.7 使用镜像创建容器，并运行 sudo docker run --name postgres-server -p 5432:5432 -e POSTGRES_PASSWORD=111111 -d postgres:9.5.7 启动容器 sudo docker start container_id 使用镜像创建一个client sudo docker run --name postgresql-client -it --link postgres-server:postgres postgres:9.5.7 psql -U postgres 此时就可以在client中的命令行上实现操作数据库啦。 2.使用docker创建mysql数据库容器 # 查询mysql镜像 sudo docker search mysql # 拉到本机 sudo docker pull mysql # 创建一个mysql服务端,并将端口映射到本机的3306端口 sudo docker run --name mysql-server -p 3306:3306 -e MYSQL_ROOT_PASSWORD=yourpassword -d mysql # 创建一个mysql客户端，用来管理数据库 sudo docker run --name mysql-client -it --link mysql-server:mysql mysql sh -c &apos;exec mysql -h&quot;$MYSQL_PORT_3306_TCP_ADDR&quot; -P&quot;$MYSQL_PORT_3306_TCP_PORT&quot; -uroot -p&quot;$MYSQL_ENV_MYSQL_ROOT_PASSWORD&quot;&apos; # 启动容器 sudo docker start container_name 注：可以通过指定mysql数据库的外部数据卷，让数据保存在本机上，便于迁移。 -v /my/own/datadir:/var/lib/mysql 其中 ：号前面是本机的数据卷地址， 这样表示宿主机的/my/own/datadir目录挂载到容器内的/var/lib/mysql目录。 现在就可以像在本机安装mysql数据库一样的使用啦。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>docker</tag>
      </tags>
  </entry>
</search>