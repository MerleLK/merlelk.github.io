<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据结构之单链表~]]></title>
    <url>%2F2017%2F08%2F02%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8D%95%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[简介：线性表实现的基本需要： 能够找到表中的首元素（无论直接或间接，通常很容易做到） 从表里的任一个元素出发，可以找到它之后的下一个元素 实现线性表的一种方式是基于链接结构，用链接显式地表示元素之间的顺序关联。基于链接技术实现的线性表称为链接表或链表 而链表有存在单向链表和双向链表，今天我们先介绍以下单向链表(单链表) 链表的单元是节点Node 每个结点（对象）有自己的标识（下面也常直接称其为链接） 结点之间通过结点链接建立起顺序联系 给表的最后一个结点（表尾结点）的链接域设置一个不会作为结点对象标识的值（Python 里自然应该用 None），称为空链接 简单的节点实现代码：class Node(object): def __init__(self, x, nxt): self.val = x self.next = nxt 对单链表的基本操作：1.创建空链表:对于链表而言只需要将表头变量设置为空链接 在Python中我们将其设置为None即可 2.删除链表:丢弃表的所有节点 在python中我们只需要简单的将表指针设为None，就丢掉了整个链表的所有节点，Python的存储管理系统会自动回收掉不用的存储。 3.判断链表是否为空: 将表头变量的值与空链接进行比较 在Python中我们只需要检查其值是否为None即可 4.判断链表是否满 链表不会满， 除非存储空间全部用完 5.首端加入元素 1）创建一个新结点存入数据2）把原链表首节点的连接存入新结点的链接域3) 修改表头变量使之引用新结点 6.尾端加入元素 1) 创建一个新结点存入数据2) 表空时直接让表头变量引用这个新结点并结束，否则找到表尾结点3) 令表尾结点的链接域引用这一新结点，并将新结点的链接域设置为空链接 7.定位加入元素 1) 找到新结点加入位置的前一结点，不存在时结束2) 创建新结点存入数据3) 修改前一结点和新结点的链接域将结点连入 8.首端删除元素 直接修改表头指针，使之引用当时表头结点的下一个结点。Python 系统里会自动回收无用对象的存储块，下同 9.尾端删除元素 找到倒数第二个结点，将其链接域设置为空链接 10.定位删除元素 找到要删除元素所在结点的前一结点，修改它的链接域将要求删除的结点从表中去掉 代码实现：单链表# 单向链表 class SinglyLinkedList(object): def __init__(self): self.head = None # 判空只需要判断指向的下一个节点是否为None def is_empty(self): return self.head is None # 链表首端加入新元素 def prepend(self, element): self.head = Node(element, self.head) # 尾端加入新元素 def append(self, element): # 判断是否为空链表, 是就直接添加 if self.head is None: self.head = Node(element, None) return # 链表不为空, 遍历得到表里最后一个节点, 然后用这个节点的next域记录新结点的链接 p = self.head while p.next is not None: p = p.next p.next = Node(element, None) # 首端弹出元素 def pop(self): if self.head is None: raise ValueError value = self.head.val self.head = self.head.next return value # 弹出尾端元素 def pop_last(self): # 首先判断是否为空链表 if self.head is None: raise ValueError p = self.head # 如果链表只有一个元素 if p.next is None: value = p.val self.head = None return value # 遍历链表 直到找到最后一个节点, 将前一个节点的next置为None while p.next.next is not None: p = p.next value = p.next.val p.next = None return value # 查找元素 def find(self, element): p = self.head while p is not None: if element == p.val: return p.next.val p = p.next return None # 打印出所有元素 def print_all(self): p = self.head while p is not None: print(p.val, end=&quot;&quot;) p = p.next print(&quot;&quot;) 带有尾结点的单链表# 带尾结点引用的单链表 尾结点引用---&gt;即指向最后一个节点 # 较之上一个实现, 有效的解决了尾端插入的效率问题 class SinglyLinkedListWithRearReference(SinglyLinkedList): def __init__(self): SinglyLinkedList.__init__(self) self.rear = None # 首端加入新元素 def prepend(self, element): # 如果为空列表, 就将将元素置为第一个,并将尾节点引用指向当前节点 self.head = Node(element, self.head) if self.rear is None: self.rear = self.head # 尾端加入新元素 def append(self, element): if self.head is None: # 直接调用首端加入, 对于第一个元素, 加入都是一致的 self.prepend(element) else: # 尾端加入新的元素时, 将尾结点引用指向当前新加入的节点 self.rear.next = Node(element, None) self.rear = self.rear.next # 从首端删除元素 def pop(self): if self.head is None: raise ValueError value = self.head.val # 如果尾结点引用指向了头结点, 那么说明 当前链表只有一个元素节点, 删除之后需要将尾结点引用置为None if self.rear is self.head: self.rear = None # 将链表的头指向下一个元素节点 self.head = self.head.next return value # 从尾端删除元素 def pop_last(self): if self.head is None: raise ValueError val = self.rear.val p = self.head while p.next.val != val: p = p.next p.next = None self.rear = p 循环单链表# 循环单链表 不必要使用单链表为基类 class CircularSinglyLinkedList(object): def __init__(self): self.rear = None # 判断是否为空 def is_empty(self): return self.rear is None # 首端加入新元素 def prepend(self, element): p = Node(element, None) # 如果是空链表，就要建立初始的循环链接， 即自己链接自己 if self.rear is None: p.next = p self.rear = p # 链表不空，就要链接在尾结点之后， 就是首结点 else: p.next = self.rear.next # 先将原来的首结点链接在自己的后边 self.rear.next = p # 自己成为首结点 # 尾端加入新元素 def append(self, element): # 直接调用之前的加入操作 self.prepend(element) # 将尾节点置换为新加入的结点 self.rear = self.rear.next # 删除首端元素 def pop(self): # 首先判断是否为空列表 if self.rear is None: raise ValueError p = self.rear.next # 如果尾节点指向自己，说明只有一个结点， 弹出结点之后 将尾节点置空 if self.rear is p: self.rear = None # 正常情况下，删除首结点，并将首结点置为原来首结点的下一个 else: self.rear.next = p.next return p.val # 删除尾端元素 def pop_last(self): # 首先判断是否为空列表 if self.rear is None: raise ValueError p = self.rear.next if p is self.rear: self.rear = None return p.val while p.next is not self.rear: p = p.next p.next = self.rear.next self.rear = p return p.val # 遍历所有结点 def print_all(self): p = self.rear.next while True: print(p.val, end=&quot;&quot;) if p is self.rear: print(&quot;&quot;) break p = p.next 对于单链表的一些操作：from data_structure.link_list.singly_linked_list import SinglyLinkedList # 反序链表 def reverse_by_singly(my_list): &quot;&quot;&quot; 使用修改链接关系： 1如果一直向首端添加结点，最先进去的就会在尾结点 2一直从首端取元素，最后得到的时尾结点。 这样就可以实现反转算法了 :param my_list: 被操作的链表 :return: 无 &quot;&quot;&quot; p = None while my_list.head is not None: q = my_list.head my_list.head = q.next q.next = p p = q my_list.head = p # 基于移动元素的单链表排序 def sort_linked_list_by_move_value(my_list): &quot;&quot;&quot; 为了有效实现，算法只能从头到尾方向检查和处理。 每次拿出一个元素，在已排序的序列中找到正确位置插入 :param my_list: 被操作的链表 :return: 无 &quot;&quot;&quot; if my_list.head is None: return crt = my_list.head.next # 计算从首结点之后开始，即首结点已排序完毕 while crt is not None: x = crt.val p = my_list.head # 从原链表的首结点开始进行比较，存在如下情况 # 1. 当前结点的值大于已排序完毕的结点，跳过 while p is not crt and p.val &lt;= x: p = p.next # 2. 当前结点的值小于已排序完毕的结点， 交换元素位置 while p is not crt: x, p.val = p.val, x p = p.next crt.val = x crt = crt.next # 基于调整链接关系实现排序工作 def sort_linked_list_by_change_relation(my_list): &quot;&quot;&quot; 基本处理模式与移动元素类似. 但是这里不在结点之间移动表元素，而是把被处理的结点取下来接到正确的位置上。 :param my_list: 被操作的链表 :return: 无 &quot;&quot;&quot; # 判断链表是否为空 if my_list.head is None: return # 初始 已排序的段只有一个结点 last = my_list.head # 表示已排序段的尾结点 crt = last.next # 待排序段的首结点 # 顺序链表的结点，每次处理一个结点 while crt is not None: # 设置扫描指针的初始值 p = my_list.head # 已排序，并且比较完毕的段 q = None # 已排序但为比较完毕的段 while p is not crt and p.val &lt;= crt.val: # 顺序更新两个扫描指针 q = p p = p.next # 当 p 是 crt 时 不需要修改链接，设置last到下一个结点crt if p is crt: last = crt else: # 取出当前结点 last.next = crt.next # 接好后置链接 crt.next = p if q is None: # 作为新的首结点 my_list.head = crt else: # 接在表中间 q.next = crt # crt 指向last的下一个结点 crt = last.next 经典的Josephus问题(使用循环单链表解决)：&quot;&quot;&quot; @description: 经典问题 Josephus问题 @author: merleLK @contact: merle.liukun@gmail.com @date: 17-8-2 @detail: 问题描述： 设有n个人围坐一圈，现在从第k个人开始报数，报到第m的人退出。 然后继续报数，直至所有人退出。输出出列人顺序编号。 &quot;&quot;&quot; from data_structure.link_list.singly_linked_list import CircularSinglyLinkedList # 基于list和固定大小的数组 def josephus_list(n, k, m): &quot;&quot;&quot; 1.建立一个包含n个人（编号）的list 2.找到k个人， 从那里开始 处理过程中，把对应的表元素修改为0表示人已经退出 3.反复操作： 数m个（在席）人 把表示第m个人的元素修改为0 Tips: 数到list最后元素之后转到下标为0的元素继续 :param n: 列表的长度 :param k: 开始位置 :param m: 退出条件 :return: 无 &quot;&quot;&quot; people = list(range(1, n + 1)) print(people) i = k - 1 # 开始位置的下标 for num in range(n): count = 0 # 报数编号 # 一次循环最多到m， 此时就会把最后一个人踢出 while count &lt; m: if people[i] &gt; 0: count += 1 if count == m: print(people[i], end=&quot;&quot;) people[i] = 0 i = (i + 1) % n # 遍历到最后一个位置就会从首位再次开始 print(&quot;,&quot; if num &lt; n - 1 else &quot;\n&quot;, end=&quot;&quot;) def josephus_list_pop(n, k, m): &quot;&quot;&quot; 1.算出应该退出的元素之后, 将其从表中删除 2.直至表长度为0的时候结束 复杂度： O(n^2) :param n: 列表的长度 :param k: 开始位置 :param m: 退出条件 :return: 无 &quot;&quot;&quot; people = list(range(1, n + 1)) i = k - 1 for num in range(n, 0, -1): i = (i + int(m) - 1) % num print(people.pop(i), end=&quot;&quot;) print(&quot;,&quot; if num &gt; 1 else &quot;\n&quot;, end=&quot;&quot;) class JosephusLinkedList(CircularSinglyLinkedList): &quot;&quot;&quot; 1.从形式看，循环单链表很好地表现了围坐一圈的人 2.顺序的数人头，很好的符合了循环表中沿着next链扫描 3.某人退出之后，删除相应结点，之后可以继续沿着原来的方向数人头 算法复杂度 O(m*n) &quot;&quot;&quot; def __init__(self, n, k, m): CircularSinglyLinkedList.__init__(self) # 创建包含n个元素的循环链表 for i in range(n): self.append(i + 1) # 将初始结点移动到k处 self.turn(k - 1) # 循环弹出第m个元素直到链表为空 while not self.is_empty(): self.turn(m - 1) print(self.pop(), end=&quot;&quot;) print(&quot;,&quot; if self.rear is not None else &quot;\n&quot;, end=&quot;&quot;) # 将循环表对象的rear指针沿着next移动了m步 def turn(self, m): for i in range(m): self.rear = self.rear.next if __name__ == &apos;__main__&apos;: josephus_list(10, 2, 7) josephus_list_pop(10, 2, 7) JosephusLinkedList(10, 2, 7) 源代码已经放置于我的github.]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python函数之format]]></title>
    <url>%2F2017%2F07%2F28%2Fpython%E5%87%BD%E6%95%B0%E4%B9%8Bformat%2F</url>
    <content type="text"><![CDATA[python format 函数总结文章基于Python2.7.12进行讲述： &#160;&#160;&#160;&#160;在python中格式化字符串进行输出时，通常会用到format函数。 &#160;&#160;&#160;&#160;介绍一下简单用法： &#160;&#160;&#160;&#160;1.将字符串替换 In [1]: print &apos;{0} {1} {2}&apos;.format(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;) a b c &#160;&#160;&#160;&#160;2.按照参数格式化 In [2]: print &apos;{name} {age}&apos;.format(age=21, name=&apos;lkhardy&apos;) lkhardy 21 &#160;&#160;&#160;&#160;3.限制字符串内的信息范围 In [3]: print &apos;{array[5]}&apos;.format(array=range(10)) 5 In [4]: print &apos;{array[12]}&apos;.format(array=range(10)) -------------------------------------IndexError Traceback (most recent call last) &lt;ipython-input-13-e9cd5827deae&gt; in &lt;module&gt;()----&gt; 1 print &apos;{array[12]}&apos;.format(array=range(10)) IndexError: list index out of range &#160;&#160;&#160;&#160;4.直接调用系统函数 In [14]: print &apos;{attr.__class__}&apos;.format(attr=0) &lt;type &apos;int&apos;&gt; In [15]: print &apos;{attr.__class__}&apos;.format(attr=&quot;d&quot;) &lt;type &apos;str&apos;&gt; &#160;&#160;&#160;&#160;5.转义 In [18]: print &apos;{name!r}&apos;.format(name=u&apos;汉字&apos;) u&apos;\u6c49\u5b57&apos; In [19]: print &apos;{name!r}&apos;.format(name=u&apos;lkhardy&apos;) u&apos;lkhardy&apos; In [20]: print &apos;{name!r}&apos;.format(name=u&apos;1234&apos;) u&apos;1234&apos; &#160;&#160;&#160;&#160;6.识别格式化 In [24]: print &apos;{digit:*^ 10.5f}&apos;.format(digit=1.0/3) * 0.33333* In [25]: print &apos;{digit:*^ 10.5f}&apos;.format(digit=10.0/3) * 3.33333* 未完待续。。。。。。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python的虚拟环境]]></title>
    <url>%2F2017%2F07%2F28%2FPython%E7%9A%84%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[简述：&#160;&#160;&#160;&#160;问题：&#160;&#160;&#160;&#160;我们知道Python的魅力更在于它庞大的第三方库。所以在实际的开发环境中，可能会同时进行多个项目，也许就会出现一个项目是基于python2.x，而另一个项目是基于python3.x的尴尬情况，以及其他很多不方便的情况，比如无法自动生成requirements文件etc。。。。。&#160;&#160;&#160;&#160;Methods：&#160;&#160;&#160;&#160;于是就有virtualenv这个插件很好的解决了这个问题。下面讲解它的基础使用。以及更为方便的一个插件virtualenvwrapper。 使用virtualenv&#160;&#160;&#160;&#160;安装&#160;&#160;&#160;&#160;virtualenv的安装十分简单，使用pip就能很方便的安装： sudo pip install virtualenv &#160;&#160;&#160;&#160;基础操作&#160;&#160;&#160;&#160;1.创建虚拟环境&#160;&#160;&#160;&#160;使用如下命令即可在当前目录下创建一个名为env1的虚拟环境 virtualenv env1 &#160;&#160;&#160;&#160;还可以创建指定解释器版本的虚拟环境 virtualenv -p python2.7 env2.7 #该环境下解释器为python2.7virtualenv -p python3.5 env3.5 #该环境下解释器为python3.5 &#160;&#160;&#160;&#160;如果你的系统里的python已经安装第三方库，你想直接继承过来使用，使用如下命令 virtualenv –system-site-packages env &#160;&#160;&#160;&#160;默认的是不加继承的，或者使用以下命令 virtualenv –no-site-packages env &#160;&#160;&#160;&#160;2.启动和退出虚拟环境&#160;&#160;&#160;&#160;启动，要想启动创建好的虚拟环境，需要到其安装目录(即当前目录下)，输入如下命令： source env1/bin/activate 当命令行头出现(env1)时就表示虚拟环境已经启动。此时我们再次使用pip、setools、easy_install等安装的插件就只会在此虚拟环境之下，不会影响系统内的默认环境、或者其他的虚拟环境。 &#160;&#160;&#160;&#160;退出，要想从当前虚拟环境之下退出，只需执行如下命令即可： deactivate 使用virtualenvwrapper&#160;&#160;&#160;&#160;virtualenv的出现使得项目间的环境使用更加方便和简洁，而virtualenvwrapper是一个基于virtualenv之上的一个工具，它提供了更加方便的虚拟环境管理方式。即统一管理。 &#160;&#160;&#160;&#160;安装 &#160;&#160;&#160;&#160;安装操作仍然十分简单，使用如下命令即可安装此工具： sudo pip install virtualenvwrapper &#160;&#160;&#160;&#160;windows下安装 pip install virtualenvwrapper-win &#160;&#160;&#160;&#160;virtualenvwrapper默认将所有的虚拟环境放在~/.virtualenvs目录下管理，但是也可以修改环境变量WORKON_HOME来指定虚拟环境的保存目录。 &#160;&#160;&#160;&#160;基本操作&#160;&#160;&#160;&#160;1.启动&#160;&#160;&#160;&#160;使用前需要在shell里执行： source /usr/local/bin/virtualenvwrapper.sh 为了方便使用这个命令，我们可以把如下命令加到shell的配置文件中： sudo vim ~/.profile export WORKON_HOME=$HOME/.virtualenvsexport PROJECT_HOME=$HOME/Develsource /usr/local/bin/virtualenvwrapper.sh &#160;&#160;&#160;&#160;2.相关命令&#160;&#160;&#160;&#160;列出已有的虚拟环境，命令如下： workon &#160;&#160;&#160;&#160;创建新的虚拟环境，创建完毕之后会自动切换到当前环境，命令如下： mkvirtualenv env1 &#160;&#160;&#160;&#160;列出当前环境下中所安装的包，命令如下： lssitepackages &#160;&#160;&#160;&#160;切换虚拟环境，命令如下： workon env2 &#160;&#160;&#160;&#160;退出当前环境，命令如下： deactivate &#160;&#160;&#160;&#160;删除虚拟环境，如果该环境正在使用，那么必须先退出该环境，命令如下： rmvirtualenv env1 &#160;&#160;&#160;&#160;显示指定环境的详情，命令如下： showvirtualenv env1 &#160;&#160;&#160;&#160;把指定的目录加入当前使用的环境path中，命令如下： add2virtualenv dir dir &#160;&#160;&#160;&#160;复制一份虚拟环境 cpvirtualenv source dest &#160;&#160;&#160;&#160;还可以在上面我们配置过的目录PROJECT_HOME下创建一个新项目。 mkproject project_name OK，以上就是关于virtualenv和增强工具virtualenvwrapper的简单使用介绍。另外说一点，在windows上使用时会出现一些命令使用的问题，好好搜索哦，本文是基于linux上使用的….呼呼，欢迎大家指正哦。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新博客搬迁计划]]></title>
    <url>%2F2017%2F07%2F27%2F%E6%96%B0%E5%8D%9A%E5%AE%A2%E6%90%AC%E8%BF%81%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[懒人自述很久之前用wordpress搭建一个个人博客。但是后来服务器到期了，决定搬迁一下。 新博客采用hexo搭建,主题使用next。简直完美。 正好趁此机会把之前写的博客好好整理一番。熟悉熟悉自己的技能栈。 开始找工作啦。。。。。。]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>杂项</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js遍历对象的几个方法]]></title>
    <url>%2F2017%2F07%2F26%2Fjs%E9%81%8D%E5%8E%86%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E4%B8%AA%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[有关对象遍历的几个方法。所有继承到Object的对象都会继承到hasOwnProerty()方法，此方法用来检测一个对象是否包含特定的自身属性，其与in运算符不同之处在于，hasOwnProperty方法会忽略掉那些从原型链上继承到的属性。 1.一个简单的例子： 检测对象obj是否含有自身属性’prop’. obj = new Object(); obj.prop = &apos;exists&apos;; function changeO(){ // 将prop属性删除。 obj.newprop = obj.prop; delete obj.prop; } alert(obj.hasOwnProperty(&apos;prop&apos;)); // True changeO(); alert(obj.hasOwnProperty(&apos;prop&apos;)); // False 对于从原型链上继承的属性，hasOwnProperty方法会将其忽略。而in操作符则是将原型链上的属性也涵盖。 alert(obj.hasOwnProperty(&apos;toString&apos;)); // False alert(&apos;toString&apos; in obj); // True 2.遍历一个对象所有的自身属性。忽略掉继承属性。 var buz = { fog: &apos;stack&apos;, name: &apos;hello&apos; }; for (var name in buz) { if (buz.hasOwnProperty(name)) { alert(&quot;this is fog (&quot; + name + &quot;) for sure. Value: &quot; + buz[name]); } else { alert(name); // toString or something else } } 注意： 此例子中for...in循环只会遍历可枚举的属性。 3.处理json对象转为字符串。 我们需要遍历一个json对象。 var s = &apos;{&quot;data&quot;:[{&quot;d1&quot;: &quot;c1&quot;, &quot;d2&quot;: &quot;c2&quot;}]}&apos;; var parsedData = JSON.parse(s); for(var i in parserd_data){ for(var j in parserd_data[i]){ alert(parserd_data[i][j]); console.log(parserd_data[i][j]); for (var k in parserd_data[i][j]){ alert(parserd_data[i][j][k]); } } } 这种方法有些费劲，所以可以定义一个函数进行遍历,虽然函数很长，但是对基本的情况也进行了校验，没有使用那么多的嵌套循环。 function JsonToStr(data){ var resultStr = &quot;&quot;; for (var i in data){ if (data.hasOwnProperty(i)){ if (typeof(data[i]) === &quot;object&quot;){ JsonToStr(data[i]); } else{ if(resultStr === &quot;&quot;){ resultStr = i + &quot;,&quot; + data[i]; } else{ resultStr = resultStr + &quot;,&quot; + i + &quot;,&quot; + data[i]; } } } } return resultStr; } 参考资料： MDN web docs]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScrip基本数据类型的常用操作]]></title>
    <url>%2F2017%2F07%2F25%2FJavaScrip%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[一、背景在日常项目中，发现会经常用到JS基本数据类型相关的一些操作。经常是当场搜索相关的用法。还是不利于自己学习。所以还是记录以下，增加自己的记忆。 二、字符串相关1.移除字符串中某些特定的字符。 1.1使用replace()函数替换 # 去除myStr字符串中的, : ; = &apos;[ ] &apos; + 等符号 var myStr = &quot;123,abc:456;abc=abc[]&quot;; myStr.replace(/[,:;=\[\]]+/g,&apos;&apos;); output: &quot;123abc456abcabc&quot; 1.2使用split()和join()函数 # 去掉冒号: var myString = &quot;12:30:21&quot; var handledString = myString.split(&quot;:&quot;).join(&quot;&quot;) output: &quot;123021&quot; # 去除myStr字符串中的, : ; = &apos;[ ] &apos; + 等符号 var myStr = &quot;123,abc:456;abc=abc[]&quot;; var handledString = my_str.split(/[,:;]/).join(&quot;&quot;) output: &quot;123abc456abc=abc[]&quot; 两中方法都使用了正则表达式进行处理。 2.删除字符串最后一个字符。 2.1使用substring()函数 # 去除字符串中最后一个, var myString = &quot;1,2,3,4,&quot; var handledString = myString.substring(0, s.length-1) output: &quot;1,2,3,4&quot; substring(start, end)函数，经常用于提取一个字符串中下标在[start, end)之间的子字符串。包含start,不包含end。 如果 start 与 end 相等，那么该方法返回的就是一个空串（即长度为 0 的字符串）。 如果 start 比 end 大，那么该方法在提取子串之前会先交换这两个参数。 如果 start 或 end 为负数，那么它将被替换为 0。 3.获取字符串中子字符串。 3.1 使用2.1中的substring()函数，但需要指定下标。 3.2使用substr()函数 var myString = &quot;0123456789&quot; # 获取从第6位开始的所有剩余字符, 下标从0开始 var handledString = myString.substr(5) substr(start, length)函数，用于返回一个从指定位置开始的指定长度的子字符串。 参数说明 start 必须要有，所需字符串的起始位置。 length 可选，返回的字符串中应包含字符的个数 如果start为负数，那么start=str.length+start 如果length为0或者负数，就会返回一个空字符串 如果不指定length参数，则字符串就会一直到str的末尾 4.判断字符串是否在另一个字符串中。 4.1使用indexof()函数 var fullStr = &apos;helloWorld&apos;; if(fulleStr.indexof(&apos;hello&apos;)){ alert(&apos;fullStr has str hello&apos;); } fullStr.indexof(str)函数,用于返回String对象内第一次出现子字符串的字符位置。如果没有找到子字符串就会返回-1 未完待续……………..]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[from-import和import]]></title>
    <url>%2F2017%2F07%2F24%2Ffrom-import%E5%92%8Cimport%2F</url>
    <content type="text"><![CDATA[简介：在使用Python编写项目时，我们经常使用import xx或者from xx import a去导入其他模块或者其他模块中的一些对象和方法，那么这两个语句有什么不一样的呢。在此处，做一下总结，让自己对它们的原理进行一些了解。 方法：Python提供了三种方法引入外部模块，import语句、from...import...和__import__函数。我们最为常用的是前两者。对于第三种方式，它与import语句类似，只是前者显式的将模块的名称作为字符串传递并赋值给命名空间的变量。 注意事项： 尽量优先使用import语句，如import a.B，可以访问B 有节制的使用from a import B形式，但是这样也可以直接访问B 避免使用from a import *形式，这样会污染命名空间，并且导入了哪些模块也不清晰。 import的原理Python的import机制，在Python初始化运行环境时候会预先加载一批内建模块到内存中，这些模块相关的信息存放在了sys.modules中，用户导入sys模块后使用sys.modules.items()可以显示所有预加载模块的相关信息。 当加载一个模块时，Python解释器做了以下一些事情： 在sys.modules中进行搜索，如果该模块已经存在，就将该模块导入到当前局部命名空间。加载就结束了。 如果在sys.modules中找不到该模块的名称，则为需要导入的模块创建一个字典对象，并将该对象信息插入到sys.modules中。 加载前确认是否需要对模块对应的文件进行编译，如果需要编译就要进行编译。 执行动态加载，在当前模块中的命名空间中执行编译后的字节码文件，并将其中所有的对象放入到模块对应的字典中。 无节制使用from…import…带来的问题命名空间冲突例子：有如下三个文件 在模块a和模块b中都定义了add()函数。那么我们在test文件中使用from...import...的形式导入add时，最终起作用的是哪一个呢？ # filename a.py def add(): print(&quot;add in module A&quot;) # filename b.py def add(): print(&quot;add in module B&quot;) # filename test.py from a import add from b import add if __name__ == &apos;__main__&apos;: add() 运行test.py之后，我们得到输出： &quot;add in module B&quot; 也就是说在这里起作用的是最近导入的add(),它完全覆盖了当前命名空间中之前导入的模块a中的add().所以在大型的项目中，我们所包含的包和模块数目非常多，因此使用from...import...语句将会大大增加了命名空间冲突的概率，很大可能会导致出现无法预料的错误和问题。所有有必要有节制的使用from...import...语句。 当然在以下的一些情况中可以考虑使用from...import...语句 当只需要导入部分属性或者方法时。 模块中的某些属性和方法使用频率很高导致使用a.B这种形式进行访问过于烦琐时。 某模块的文档明确说明需要使用from...import形式，能后更为简单和便利时。如使用from io.drivers import zip要比使用import iodrivers.zip更加方便。 循环嵌套导入问题例子： # filename c1.py from c2 import g def x(): pass # filename c2.py from c1 import x def g(): pass 像上边的两个文件，无论运行哪一个，都会报出ImportError的错误。解析如下： 在执行c1.py的加载过程的时候需要创建新的模块对象c1然后执行c1.py所对应的字节码，此时遇到语句from c2 import g,而此时c2在sys.modules中并不存在。然后就会创建与c2对应的模块对象并执行c2.py， 而在执行c2.py时候，又遇到from c1 import x语句，此时的c1对象虽然已经存在，但是初始化的过程并未完成，所以不存在x对象，所以c2也无法初始化完成。 再次执行c1.py时，就会报出ImportError: cannot import name g异常。 而使用import可以解决这个问题。修改文件如下： # filename c1.py import c2 def x(): pass # filename c2.py import c1 def g(): pass 此时就可以运行这两个文件了。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[collections模块之namedtuple使用]]></title>
    <url>%2F2017%2F07%2F23%2Fcollections%E6%A8%A1%E5%9D%97%E4%B9%8Bnamedtuple%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[简介在python中tuple是一个不可变的且轻量型的集合对象，但是使用时，我们只能通过索引的方式去获取元组中的元素。不太方便，并且容易出错。而在collections模块中namedtuple对象则给出了一个更加便捷的操作方式，即给元组中的元素命名。它可以被用作类似于struct或其他常见record types，但它们是不可变的。 简单使用1.创建namedtuple form collections import namedtuple Point = namedtuple(&apos;Point&apos;, &apos;x y&apos;) point1 = Point(1.0, 5.0) point2 = Point(2.5, 1.5) 上例即创建了一个名字为Point的namedtuple对象. 2.namedtuple对象的参数解析 a.示例中的Point是namedtuple的名称。 b.示例中的x y这个字符串中的两个用空格隔开的字符表示这个namedtuple中有两个元素，名为x,y.(避免关键字) c.如果在数据库中读列名作为元素名时可能会出现相同名，程序会报错，那么可以在定义namedtuple时开启自动重命名。如下： Point = namedtuple(‘Point’, ‘x y’， rename=True) 此时命名方式为_indexnumber,下划线+索引号。 调用方式3.1索引方式调用 对于示例中的定义的Point1,可以采用索引方式调用获取其中的值. In [7]: x = point1[0] Out : 1.0 In [10]: y = point1[1] Out : 5.0 3.2元素名方式调用 对于示例中的定义的Point2,可以采用元素名调用获取其中的值. In [12]: x = point2.x Out : 2.5 In [14]: y = point2.y Out : 1.5 总结4.1 你应该使用namedtuple代替那些你认为影响了你代码的易读性的tuple，以便让你的代码更加pythonic. 4.2 此外，你还可以替换那些没有功能函数、只有字段的普通不可变类。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker简单使用]]></title>
    <url>%2F2017%2F07%2F22%2Fdocker%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[简介:Docker是一个开源的引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在笔记本上编译测试通过的容器可以批量地在生产环境中部署，包括VMs（虚拟机）、bare metal、OpenStack 集群和其他的基础应用平台。Docker通常用于如下场景： web应用的自动化打包和发布； 自动化测试和持续集成、发布； 在服务型环境中部署和调整数据库或其他的后台应用； 从头编译或者扩展现有的OpenShift或Cloud Foundry平台来搭建自己的PaaS环境 删除：1.删除container a.单独删除具体某一个容器 ➜ ~ sudo docker rm CONTAINER_ID ➜ ~ sudo docker rm -f 删除运行中的容器 b.删除当前所有容器(已终止运行) ➜ ~ sudo docker rm $(sudo docker ps -a -q) 2.删除image a.删除某个镜像 ➜ ~ sudo docker rmi &lt;image_id&gt; b.删除所有镜像 ➜ ~ sudo docker rmi $(sudo docker images -q) c.删除所有untagged的镜像(就是id为None的镜像) ➜ ~ sudo docker images | grep &quot;^&lt;none&gt;&quot; | awk &quot;{print $3}&quot; 查看：1.查看所有容器 ➜ ~ sudo docker ps -a 2.查看所有正在运行的容器 ➜ ~ sudo docker ps 3.查看镜像 ➜ ~ sudo docker images 运行：1.创建一个container ➜ ~ sudo docker run image_name 2.启动一个container ➜ ~ sudo docker run container_name 3.重命名container ➜ ~ sudo docker rename old_name new_name 4.重启某个容器 ➜ ~ sudo docker restart container_name Tips: docker run 的相关参数说明: --name 指定容器名 -p 指定端口映射 eg 3306:3306 -v 挂载数据卷或者本地目录映射 :ro 挂载为只读 -d 后台持续运行 -i 交互式操作 -t 终端 -rm 容器退出后随之将其删除(与-d 冲突) 停止：1.停止所有正在运行的容器 ➜ ~ sudo docker kill $(docker ps -q) 相关示例：1.使用docker创建postgresql数据库容器 sudo docker search postgres sudo docker pull postgres:9.5.7 使用镜像创建容器，并运行 sudo docker run --name postgres-server -p 5432:5432 -e POSTGRES_PASSWORD=111111 -d postgres:9.5.7 启动容器 sudo docker start container_id 使用镜像创建一个client sudo docker run --name postgresql-client -it --link postgres-server:postgres postgres:9.5.7 psql -U postgres 此时就可以在client中的命令行上实现操作数据库啦。 2.使用docker创建mysql数据库容器 # 查询mysql镜像 sudo docker search mysql # 拉到本机 sudo docker pull mysql # 创建一个mysql服务端,并将端口映射到本机的3306端口 sudo docker run --name mysql-server -p 3306:3306 -e MYSQL_ROOT_PASSWORD=yourpassword -d mysql # 创建一个mysql客户端，用来管理数据库 sudo docker run --name mysql-client -it --link mysql-server:mysql mysql sh -c &apos;exec mysql -h&quot;$MYSQL_PORT_3306_TCP_ADDR&quot; -P&quot;$MYSQL_PORT_3306_TCP_PORT&quot; -uroot -p&quot;$MYSQL_ENV_MYSQL_ROOT_PASSWORD&quot;&apos; # 启动容器 sudo docker start container_name 注：可以通过指定mysql数据库的外部数据卷，让数据保存在本机上，便于迁移。 -v /my/own/datadir:/var/lib/mysql 其中 ：号前面是本机的数据卷地址， 这样表示宿主机的/my/own/datadir目录挂载到容器内的/var/lib/mysql目录。 现在就可以像在本机安装mysql数据库一样的使用啦。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>linux</tag>
      </tags>
  </entry>
</search>