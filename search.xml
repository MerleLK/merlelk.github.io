<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[我学算法之寻找缺失的整数]]></title>
    <url>%2F2017%2F08%2F09%2F%E6%88%91%E5%AD%A6%E7%AE%97%E6%B3%95%E4%B9%8B%E5%AF%BB%E6%89%BE%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[有关数组里需找数字的算法题目 一个无序数组里有99个不重复正整数，范围从1到100，唯独缺少一个整数。如何找出这个缺失的整数？ 解决办法一： 构建一个字典，以1-100为key，初始value均为0. 遍历原来数组，读到一个数，就将其对应的value设置为1. 遍历字典，得到value为0的key。就是数组中缺失的数字 代码实现： def check(my_list): # 初始化字典 my_dict = {} for i in range(100): my_dict.update({i + 1: 0}) # 遍历数组，并操作字典 for i in my_list: my_dict[i] = 1 # 遍历字典得到缺失值。 for i in range(100): if my_dict[i + 1] == 0: return i + 1 算法时间复杂度为O(n)， 空间复杂度为O(n) 解决办法二： 先对原数组进行排序。 逐一判断，相邻元素是否为连续。 不连续的话，中间元素的就是我们要找的结果。 如股票全部连续，那么缺失的就是1或者100. 代码实现： def sort_check(my_list): # 首先排序 my_list.sort() # 先判断1和100是否存在 if 1 not in my_list: return 1 if 100 not in my_list: return 100 # 寻找缺失的数字 for i in range(len(my_list)-1): if my_list[i+1] - my_list[i] != 1: return my_list[i] + 1 解决办法三： 当前情况下最佳，也最简单。 由于题目要求计算1-100之间的缺失的整数且不重复！ 那么就可以先计算1+…+100的和，再减去数组中的数字 得到的结果就是我们寻找的数字。 代码实现： def simple_check(my_list): # 计算1-100的和 result = sum([i + 1 for i in range(100)]) # 逐一相减得到最后结果 for i in my_list: result -= i return result 题目： 一个无序数组里有若干个正整数，范围从1到100，其中99个整数都出现了偶数次，只有一个整数出现了奇数次（比如1,1,2,2,3,3,4,5,5），如何找到这个出现奇数次的整数？ 解决办法： 我们知道异或运算时，相同位的结果为0，不同位的结果为1.那么就可以按照这个规则进行处理了。 对数组中的每个数注意异或相加， 因为其他的数字都是偶数次，所以最后的结果都是0 对于唯一出现奇数次的数字，就是最终的结果 代码实现： def check_one_num(my_list): result = 0 for i in my_list: result ^= i return result 题目： 一个无序数组里有若干个正整数，范围从1到100，其中98个整数都出现了偶数次，只有两个整数出现了奇数次（比如1,1,2,2,3,4,5,5），如何找到这个出现奇数次的整数？ 解决思路： 我们依旧可以一句第二道题的思路，但是难点在于存在两个整数出现奇数次。注意到数字的二进制表示是唯一的，所以我们发现这两个缺失的数可以依据某些条件分成两个数组中，遵循分治法的要求。 解决办法： 首先对数组中的所有数字进行异或，最终的结果转换为二进制。 假如转换后的二进制是00000101(就是数字5)那么我们可以选择任意一个1所在的二进制位来分开原数组。 比如我们选择末位，所以可以分开来两部分。而缺失的两个数分别在一部分。 再对分开的数字进行异或，最终可以得到这两个数。 代码实现： def check_two_num(my_list): result = 0 num1 = 0 num2 = 0 # 先异或出原来数组的结果 for i in my_list: result ^= i # 寻找出我们需要的1 tail = str(bin(result)).rindex(&apos;1&apos;) flag = str(bin(result))[tail:] # 按照条件分开数组，直接计算出最终结果。 for i in my_list: if str(bin(i)).endswith(flag): num1 ^= i else: num2 ^= i return num1, num2 代码放置与 我的github上 题目来源： 寻找缺失的整数]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python函数参数总结]]></title>
    <url>%2F2017%2F08%2F09%2Fpython%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[参数传递Python中的参数传递存在以下几种情况： 基本定义方式这是最常见的定义方式。 def foo(arg1, atg2,...) pass 一个函数可以定义任意个参数，参数中间使用,隔开，使用这种定义方式的函数在调用的时候，必须提供所有的参数，并且顺序也要一致。否则就会报错。 提供默认值的参数这种方式就是第一种方式的稍微改进版本。 def foo(arg1, arg2=2): pass 此时，调用这个函数的时候，可以只传递arg1一个参数，因为arg2存在默认值，接收不到参数时，就是使用默认值。 使用单个星号 *在程序中，有时候我们可能不太清楚有多少个参数，所以可以使用*来传递不确定的参数。 def foo(*args): pass 在参数名前边加上*号就是让函数可以接受任意多的位置参数，但是不管传递的参数有多少个，都会存储在一形参名为标识符的tuple中。 使用双星号 **在形参名的前边加上**,参数在函数的内部将会存为形参名为标识符的字典中。并且是以关键字参数为key，位置参数为value的字典。 def foo(**kwargs): pass 在函数调用的时候，要以foo(arg1=value1, arg2=value2)这种形式调用。这样内部使用的时候可以直接调用args1和arg2。 Tips：函数参数在调用过程中是以上述四中方式优先级依次降低的次序执行解析的。 zip函数这时候理解zip函数中的*就十分简单了。 我们需要多个参数，但是想以list作为参数。就可以使用* a = [[1,2,3,4], [&apos;1a&apos;, &apos;2a&apos;, &apos;3a&apos;, &apos;4a&apos;]] result = zip(*a) for i in result: print(i) # output: (1, &apos;1a&apos;) (2, &apos;2a&apos;) (3, &apos;3a&apos;) (4, &apos;4a&apos;) 所以我们可以使用zip函数进行矩阵的转换。 a = [[1,2,3], [4,5,6], [7,8,9]] for i in zip(*a): print(i) # output (1, 4, 7) (2, 5, 8) (3, 6, 9) .]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker-compose部署web项目]]></title>
    <url>%2F2017%2F08%2F08%2Fdocker-compose%E9%83%A8%E7%BD%B2web%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[需求： 要在docker中运行运行Web项目 需要一个数据库存储 部署简易。 解决：基于docker-compose实现部署项目 当前项目结构 ├── db_proj│ ├── db.sql│ └── Dockerfile├── docker-compose.yml└── web_proj ├── DataPlatformSystem │ ├── manage.py │ ├── README.md │ ├── requirements.txt │ ├── tests │ │ └── __init__.py │ └── webapp │ ├── config.py │ ├── __init__.py └── Dockerfile docker-compose的配置文件内容 db: build: ./db_proj # image: postgres:9.5 environment: - POSTGRES_USER=postgres - POSTGRES_PASSWORD=111111 # - POSTGRES_DB=testDB ports: - &quot;5432:5432&quot; web: build: ./web_proj command: python /app/DataPlatformSystem/manage.py volumes: - /app/DataPlatformSystem ports: - &quot;5000:5000&quot; - &quot;8001:8001&quot; - &quot;9001:9001&quot; links: - db lables: com.dragonteam.des: &quot;数据管理平台&quot; com.dragonteam.department: &quot;DragonTeam&quot; com.dragonteam.release: &quot;v0.5&quot; db_proj下的Dockerfile FROM postgres ENV POSTGRES_DB test COPY db.sql /docker-entrypoint-initdb.d/ web_proj下的Dockerfile FROM ubuntu COPY DataPlatformSystem /app/DataPlatformSystem WORKDIR /app/DataPlatformSystem RUN buildDeps=&apos;python python-pip python-dev python-tk&apos;\ &amp;&amp; cp /etc/apt/sources.list /etc/apt/sources.list.bak \ &amp;&amp; sed -i &apos;s/archive.ubuntu.com/mirrors.ustc.edu.cn/g&apos; /etc/apt/sources.list \ &amp;&amp; apt-get update &amp;&amp; apt-get install --assume-yes apt-utils \ &amp;&amp; apt-get install -y $buildDeps \ &amp;&amp; pip install --upgrade pip \ &amp;&amp; pip install -r /app/DataPlatformSystem/requirements.txt 所遇问题：数据库容器连接问题：如果web应用的容器和数据库服务的容器分离，就要使用links指定关联、 links: - db 那么在web应用中的配置信息中就要使用此配置信息， SQLALCHEMY_DATABASE_URI = &apos;postgresql://postgres:111111@db/test&apos; 其中的db就是links的配置内容。 路径问题：在docker-compose.yml中使用build命令时，指定的路径可以是绝对路径，或者是相对于docker-compose.yml文件的相对路径。 build: /path/to/build/dir 参考资料： Docker从入门到实战 Docker部署Flask项目 使用docker-compose docker-postgres-issue Docker初始化导入数据库文件]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pip can not install MarkupSafe]]></title>
    <url>%2F2017%2F08%2F07%2Fpip-can-t-install-MarkupSafe%2F</url>
    <content type="text"><![CDATA[背景今天早上试用pyecharts时（环境：Python3.6.1），使用pip安装.在安装时报出错误。此错误应该是针对于（MarkupSafe）模块的。如下： 解决问题1、通过traceback可以看到应该是pip命令将控制台的字符串进行编码转换时出现了错误。因为我这是在windows下进行的，所以console上使用的是gbk的编码，但是pip模块却使用utf-8进行解码，所以产生了错误。找到对应的出错位置，我们修改一下对应的代码。找到\lib\site-packages\pip\compat\__init__.py文件定位到第75行： 我们将原来的utf_8修改为gbk. 执行 pip freeze命令，如果存在安装包（MarkupSafe）， 先进行卸载。 重新安装。 发现没有问题。 同样环境在Linux下却不会出现问题，因为Linux的console默认utf-8编码。如图(Konsole)：]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础之迭代器+生成器]]></title>
    <url>%2F2017%2F08%2F06%2FPython%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8-%E7%94%9F%E6%88%90%E5%99%A8%2F</url>
    <content type="text"><![CDATA[迭代器(iterator)简介迭代器是访问集合内元素的一种方式。迭代器对象从集合的第一个元素开始访问，直到所有的元素都被访问一遍后结束。 优点： 对于无法随机访问的数据结构(比如set)而言,迭代器是唯一的访问元素的方式。 迭代器不要求你事先准备好整个迭代过程的所有的元素，它仅仅是在迭代至某一个元素时才计算该元素。在这之前或者之后，元素可以不存在或者被销毁。适合巨大的或者无限的集合。 迭代器提供了一个统一的访问集合的接口。只要实现了iter()方法的对象，就可以使用迭代器进行访问。 缺点 迭代器无法回退，只能向前进行迭代。 迭代器不是线程安全的，在多线程环境中对可变集合使用迭代器是一个危险的操作。 简单使用使用内建函数iter可以从可迭代的对象中获得迭代器。 &gt;&gt;it = iter([1, 2, 3]) &gt;&gt;it.next() 1 &gt;&gt;it.next() 2 上述的it.next()可以使用next(it)替换。 如果迭代到最后一位后，再调用it.next()就会出现StopIteration的异常。但是我们可以通过检测到异常信息，来退出迭代器。 使用迭代器的循环可以避开索引，但有时候我们还是需要索引来进行一些操作的。这时候内建函数enumerate就派上用场咯，它能在iter函数的结果前加上索引，以元组返回，用起来就像这样： &gt;&gt;lst = range(3) &gt;&gt;for idx, ele in enumerate(lst): &gt;&gt; print idx, ele 0 0 1 1 2 2 Tips：使用list的构造方法显式地将迭代器转化为列表、 生成器(Generator)简介生成器是一种用普通函数语法定义的迭代器。它主要依赖于yield关键字，任何包含yield语句的函数都称为生成器。 生成器和函数的主要区别在于函数return a value，生成器yield a value同时标记且记忆point of the yield 以便于在下次调用时从标记点恢复执行。 示例学习创建生成器 我们创建一个函数，用来展开列表的列表的值顺序打印。 In [35]: my_list = [[1, 2], [3, 4], [5]] In [36]: def un_fold(the_list): ...: for _list in the_list: ...: for element in _list: ...: yield element ...: In [37]: list(un_fold(my_list)) Out[37]: [1, 2, 3, 4, 5] 在这里，就是一个生成器，如果我们将yield element换成print element那么就是一个普通的函数。区别就在于，生成器并没有return一个值，而是产生多个值。每次产生一个值(即使用yield语句),函数就被冻结：重新唤醒后，就会延续刚才运行的状态继续。 递归生成器 Demo: In [38]: def flatten(the_list): ...: try: ...: for sublist in the_list: ...: for element in flatten(sublist): ...: yield element ...: except TypeError: ...: yield the_list ...: In [39]: list(flatten([[[1],2], 3,4, [5, [6, 7]], 8])) Out[39]: [1, 2, 3, 4, 5, 6, 7, 8] 在函数flatten被调用时存在两种可能性： 函数被告知展开一个元素时(如一个数字),这时，for循环会出现一个TypeError,生成器会产生一个元素。 如果展开的是一个列表(或者其他迭代器对象)，那么程序就会遍历所有的子列表(一些也可能不是列表)，并对他们调用flatten函数。然后用另一个flatten函数展开子列表中的所有元素。 但是上述的例子由一个问题。如果the_list是一个类似字符串的对象。那么它就是一个序列，不会引发TypeError，但是我们不想对这样的对象进行迭代。所以我们可以在生成器的开始添加一个检查语句。如下 # demo2 In [6]: def flatten(the_list): ...: try: ...: try: the_list + &apos;&apos; ...: except TypeError: pass ...: else: raise TypeError ...: for sublist in the_list: ...: for element in flatten(sublist): ...: yield element ...: except TypeError: ...: yield the_list ...: In [7]: list(flatten([&apos;foo&apos;, [&apos;bar&apos;, [&apos;baz&apos;]]])) Out[7]: [&apos;foo&apos;, &apos;bar&apos;, &apos;baz&apos;] 通用生成器 当生成器被调用时，在函数体的代码不会被执行，而会返回一个迭代器。每次请求一个值，就会执行生成器的代码，直到遇到一个yield或者return语句。yield语句意味着应该生成一个值，return语句意味着生成器要停止运行(不在生成任何东西,return语句只有在一个生成器中使用时才能 进行无参数调用). 换句话说，生成器由两部分构成：生成器的函数和生成器的迭代器。生成器的函数是用def定义的，包含yield的部分。生成器的迭代器是这个函数返回的部分。 # demo In [1]: def simple_generator(): ...: yield 1 ...: In [2]: simple_generator Out[2]: &lt;function __main__.simple_generator&gt; In [3]: simple_generator() Out[3]: &lt;generator object simple_generator at 0x7f2b98d66dc0&gt; Tips： 在生成器中返回的迭代器，可以像其他的迭代器一样使用。 生成器方法 send()方法 在外部作用域访问生成器的send()方法就像访问next()方法一样，只不过前者使用一个参数(即要发送的消息—任意对象) 在内部则挂起生成器，yield现在作为表达式而不是语句来用，也就是说，在生成器重新运行时，yield函数返回一个值，也就是外部通过send方法发送的值，如果next方法被使用，那么yield返回None 注意在使用send方法，只有在生成器挂起的时候，才会有意义，否则就要提供更多信息。 demo 说明这种机制In [4]: def repeater(value):…: while True: …: new = (yield value) …: if new is not None:…: value = new…: In [5]: r = repeater(100) In [6]: r.next()Out[6]: 100 In [7]: r.send(101)Out[7]: 101 In [8]: r.send(“Alex”)Out[8]: ‘Alex’ throw方法：用于在生成器内引发一个异常（在yield表达式中） close方法:调用时不需要参数， 用于停止生成器。 使用enumerate函数普通的遍历索引+值 In [5]: seq = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;] In [6]: i = 0 In [7]: for ele in seq: ...: seq[i] = &apos;%d: %s&apos; % (i, seq[i]) ...: i += 1 ...: In [8]: print seq [&apos;0: one&apos;, &apos;1: two&apos;, &apos;2: three&apos;] 使用enumerate后 In [9]: seq = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;] In [10]: for i, ele in enumerate(seq): ...: seq[i] = &apos;%d: %s&apos; % (i, seq[i]) ...: In [11]: print seq [&apos;0: one&apos;, &apos;1: two&apos;, &apos;2: three&apos;] 更加pythonic的写法 In [12]: seq = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;] In [13]: print [&apos;%d: %s&apos; % (i, ele) for i, ele in enumerate(seq)] [&apos;0: one&apos;, &apos;1: two&apos;, &apos;2: three&apos;]]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于BBB开发板的温度检测和邮件自发送]]></title>
    <url>%2F2017%2F08%2F06%2F%E5%9F%BA%E4%BA%8EBBB%E5%BC%80%E5%8F%91%E6%9D%BF%E7%9A%84%E6%B8%A9%E5%BA%A6%E6%A3%80%E6%B5%8B%E5%92%8C%E9%82%AE%E4%BB%B6%E8%87%AA%E5%8F%91%E9%80%81%2F</url>
    <content type="text"><![CDATA[背景机房里的空调是不能关闭的，但不可避免出现各种问题。于是想通过检测室内的温度，达到某一界限时来向管理员发送通知邮件。 所用介质 1.BeagleBoneBlack开发板2.温度传感器18b203.qq邮箱 搭建过程连接开发板以数据线连接电脑USB到开发板的USB上，开机 配置BBB开发板（将温度传感器注册到开发板上）此处的教程源自One-wire DS1820 thermometer with BeagleBone Black &amp; libmicrohttpd 1.加载驱动文件（自己理解的）在开发板root目录下新建一个18b20的文件夹编辑BB-W1-00A0.dts文件 /dts-v1/; /plugin/; / { compatible = &quot;ti,beaglebone&quot;, &quot;ti,beaglebone-black&quot;; part-number = &quot;BB-W1&quot;; version = &quot;00A0&quot;; /* state the resources this cape uses */ exclusive-use = /* the pin header uses */ &quot;P9.22&quot;, /* the hardware IP uses */ &quot;gpio0_2&quot;; fragment@0 { target = &lt;&amp;am33xx_pinmux&gt;; __overlay__ { dallas_w1_pins:pinmux_dallas_w1_pins { pinctrl-single,pins = &lt; 0x150 0x37 &gt;; }; }; }; fragment@1 { target = &lt;&amp;ocp&gt;; __overlay__ { onewire@0 { compatible = &quot;w1-gpio&quot;; pinctrl-names = &quot;default&quot;; pinctrl-0 = &lt;&amp;dallas_w1_pins&gt;; status = &quot;okay&quot;; gpios = &lt;&amp;gpio1 2 0&gt;; }; }; }; }; 2.编译dts文件 键入命令： dtc -O dtb -o BB-W1-00A0.dtbo -b 0 -@ BB-W1-00A0.dts 3.加入到配置文件中 cp BB-W1-00A0.dtbo /lib/firmware/ echo BB-W1:00A0 &gt; /sys/devices/bone_capemgr.9/slots 此时你可以验证是否写入成功 cat /sys/bus/w1/devices/DEVICE_ID/w1_slave 编写源代码文件# -*- coding:utf-8 -*- import Adafruit_BBIO.GPIO as GPIO # 导入相关库文件 import time from sendMail import * GPIO.setup(&quot;P9_14&quot;, GPIO.OUT) flag=0 def read_temp_raw(): f = open(&quot;/sys/bus/w1/devices/28-04146829edff/w1_slave&quot;) lines = f.read() f.close() return lines def read_temp(): lines = read_temp_raw() secondline = lines.split(&quot;\n&quot;)[1] temperaturedata = secondline.split(&quot; &quot;)[9] temperature = float(temperaturedata[2:]) temperature = temperature / 1000 return temperature # 以一个死循环让程序持续运行，检测温度值，并发送警告邮件 while True: time.sleep(1) # 每个一秒获得一次温度值 print(read_temp()) if (read_temp() &gt; 30) &amp; (flag==0): #当 温度大于30度，并且是 send(read_temp()) print &quot;hello&quot; flag = flag+1 # GPIO.output(&quot;P9_14&quot;, GPIO.HIGH) elif (read_temp() &lt; 30) : flag= 0 配置邮件自动发送源码如下 # -*- coding: UTF-8 -*- import sys, os, re, urllib, urlparse import smtplib import traceback from email.mime.text import MIMEText from email.mime.multipart import MIMEMultipart def sendmail(subject,msg,toaddrs,fromaddr,smtpaddr,password): mail_msg = MIMEMultipart() if not isinstance(subject,unicode): subject = unicode(subject, &apos;utf-8&apos;) mail_msg[&apos;Subject&apos;] = subject mail_msg[&apos;From&apos;] = &apos;your@qq.com&apos; #此处最好填入邮箱地址，否则会被拦截 mail_msg[&apos;To&apos;] = &apos;,&apos;.join(toaddrs) mail_msg.attach(MIMEText(msg, &apos;html&apos;, &apos;utf-8&apos;)) try: s = smtplib.SMTP() s.connect(smtpaddr) #连接smtp服务器 s.ehlo() s.starttls() s.login(fromaddr,password) #登录邮箱 s.sendmail(fromaddr, toaddrs, mail_msg.as_string()) #发送邮件 s.quit() except Exception,e: print &quot;Error: unable to send email&quot; print traceback.format_exc() def send(read_temp): fromaddr = &quot;your@qq.com&quot; smtpaddr = &quot;smtp.qq.com&quot; toaddrs = [&quot;others@qq.com&quot;] subject = &quot;老师，请注意&quot; password = &quot;your password&quot; msg = &quot;你好，老师！当前温度已经达到&quot;+ str(read_temp) +&quot;度&quot; sendmail(subject,msg,toaddrs,fromaddr,smtpaddr,password) 上述代码中的stmp的starttls方法，有参考python-smtplib. 到此时基本配置已经完成。 在这里的自发送代码十分简单，想要达到自己的需求还需要加以更改。]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[archLinux初识]]></title>
    <url>%2F2017%2F08%2F06%2FarchLinux%E5%88%9D%E8%AF%86%2F</url>
    <content type="text"><![CDATA[##Arch-Linux 配置小记（一） ####一、Arch-Linux简介 #####1.简介&#160;&#160;&#160;&#160;Arch Linux是朝向轻量（lightweight）以及简单（simple）的Linux发行版。其中“简单”（Simplicity）被定义为“避免不必要或复杂的修改”，也就是说，是由开发者角度定义，而非用户角度思考。 因此，受到了许多开发者的喜爱。&#160;&#160;&#160;&#160;作为小白的我，本着对技术的好奇心。也学习一下它的简单玩法。本文纯小白文。欢迎阅读….. #####2.环境&#160;&#160;&#160;&#160;kernel：基于Arch——linux archlinux-2016.09.03-dual.iso&#160;&#160;&#160;&#160;环境：VMware Workstation12 ####二、配置过程记录 #####1.磁盘分区&#160;&#160;&#160;&#160;与其他发行版本的linux的分区不同，Arch的磁盘分区采用纯命令行的操作（包括以后的安装过程）。参阅Arch Wiki)里的相关内容。&#160;&#160;&#160;&#160;这里我们以gdisk(GPT下的fdisk)来进行磁盘分区。&#160;&#160;&#160;&#160;在VM里创建了虚拟机后，开启虚拟机，进入了命令行，此时可以查看当前的分区内容，命令： fdisk -l 此时，可以看到系统的主分区，一般为sda(sdx)。 开始进行分区： 命令： gdisk /dev/sda 进入交互模式： Command（？ for help）: 此时输入n可以开始添加分区，逐次选择分区号，起始扇区，终止扇区和文件系统类型（hex code）。 以分区1：boot，分区2：swap，分区3：根分区，分区4：home。eg：boot分区&#160;&#160;&#160;&#160;(1).分区的分区号默认为1 （boot）&#160;&#160;&#160;&#160;(2).起始扇区选择默认&#160;&#160;&#160;&#160;(3).终止扇区设置为”+300M”,表示大小为300M&#160;&#160;&#160;&#160;(4).hex code选默认（8300）表示为”Linux File System”,如果是swaq分区时则要设置为(8200)表示为swap分区 依次设置完毕后，在交互模式下键入 p 可以查看分区的详细信息，确认后可以键入 w 将分区信息写入磁盘。设置完毕后 Ctrl+c 退出交互模式，回到命令行，首先我们要将boot分区的格式设置为EFI System， 可以使用命令： parted /dev/sda (parted) set 1 boot on 分区完成之后，可以开始下一步 #####2.格式化并挂载磁盘上一步我们完成了分区，sda1~4 分别对应boot,swap,/根目录,home。首先格式化一般的存储目录。 命令： mkfs -t ext4 /dev/sda1 mkfs -t ext4 /dev/sda3 mkfs -t ext4 /dev/sda4 对于交换分区使用mkswqp命令设置格式 mkswap /dev/sda2 设置完毕之后，我们将分区挂载到文件系统上，命令： mount /dev/sda3 /mnt mount /dev/sda1 /mnt/boot mount /dev/sda4 /mnt/home swapon /dev/sda2 其中挂载swap分区的命令有点不同，另外，在挂载之前应先创建好相关的目录，命令： cd /mnt mkdir boot mkdir home 此时挂载完毕。 #####3.在挂载点安装arch此时我们使用pacstrap命令从网上安装基础包和基础开发包，在这一步之前，由于软件源的原因，我们要想完成的速度快，需要更改源。 vi /etc/pacman.d/mirrorslist 将其他地区的源删除，保留中国地区的，建议使用阿里云或者163的源在最前面。 好了开始安装，命令： pacstrap /mnt base base-devel 等待一段时间（30m）左右，即可安装完毕。此时我们要首先设置硬件启动时自动挂载分区，否则进入系统。 命令： genfstab -p /mnt &gt;&gt; /mnt/etc/fstab fstab文件的作用就是，启动时自动挂载磁盘分区，并检测交换分区（swap） #####4.安装引导bootloader系统安装完毕之后，会需要引导来进入操作系统，常见的引导有grup和syslinux,此处我们选择Syslinux。它的相关配置可以查阅 Syslinux Wiki 首先安装syslinux， 命令： pacstrap /mnt syslinux 自动配置syslinux， 命令: syslinux-install_update -i -a -c /mnt 安装完成后，键入命令：* arch-chroot /mnt 进行配置语言、时区等，其中选择语言时需要修改文件 /etc/locale.gen 建议选择英文，避免命令行乱码。 locale-gen echo LANG=&quot;en_US.UTF-8&quot; &gt; /etc/locale.conf ln -s /usr/share/zoneinfo/Asia/Shahai /etc/localtime 然后需要修改syslinux的配置信息，在/boot/syslinux/syslinux.cfg文件中有一些xxx.c32模块，需要把对应的/usr/lib/syslinux/bios/XXX.c32复制到/boot/syslinux/目录下。 主要应该有四个menu.c32、vesamenu.c32、 reboot.c32、 hdt.c32。 在运行命令： extlinux --install /boot/syslinux 此时bootloder安装完毕，此后需要增加一个启动系统的指令 即gptmbr.bin, 命令： dd conv=notrunc bs=440 count=1 if=/usr/lib/syslinux/bios/gptmbr.bin of=/dev/sda 最后，初始化磁盘环境， 命令： mkinitpio -p linux 退出chroot， 命令：exit。取消挂载，并重启，命令： umount -R /mnt swapoff /dev/sda2 重启后就可以通过syslinux引导进入arch-linux的系统了，此时的用户为root，不需要密码。当前系统只有tty(即黑窗口),并无桌面环境。 好啦，第一次先进行这么多， 下一次再对我们的arch-linux进行进一步完善。呜啦啦啦未完待续……..]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构之单链表~]]></title>
    <url>%2F2017%2F08%2F02%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8D%95%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[简介：线性表实现的基本需要： 能够找到表中的首元素（无论直接或间接，通常很容易做到） 从表里的任一个元素出发，可以找到它之后的下一个元素 实现线性表的一种方式是基于链接结构，用链接显式地表示元素之间的顺序关联。基于链接技术实现的线性表称为链接表或链表 而链表有存在单向链表和双向链表，今天我们先介绍以下单向链表(单链表) 链表的单元是节点Node 每个结点（对象）有自己的标识（下面也常直接称其为链接） 结点之间通过结点链接建立起顺序联系 给表的最后一个结点（表尾结点）的链接域设置一个不会作为结点对象标识的值（Python 里自然应该用 None），称为空链接 简单的节点实现代码：class Node(object): def __init__(self, x, nxt): self.val = x self.next = nxt 对单链表的基本操作：1.创建空链表:对于链表而言只需要将表头变量设置为空链接 在Python中我们将其设置为None即可 2.删除链表:丢弃表的所有节点 在python中我们只需要简单的将表指针设为None，就丢掉了整个链表的所有节点，Python的存储管理系统会自动回收掉不用的存储。 3.判断链表是否为空: 将表头变量的值与空链接进行比较 在Python中我们只需要检查其值是否为None即可 4.判断链表是否满 链表不会满， 除非存储空间全部用完 5.首端加入元素 1）创建一个新结点存入数据2）把原链表首节点的连接存入新结点的链接域3) 修改表头变量使之引用新结点 6.尾端加入元素 1) 创建一个新结点存入数据2) 表空时直接让表头变量引用这个新结点并结束，否则找到表尾结点3) 令表尾结点的链接域引用这一新结点，并将新结点的链接域设置为空链接 7.定位加入元素 1) 找到新结点加入位置的前一结点，不存在时结束2) 创建新结点存入数据3) 修改前一结点和新结点的链接域将结点连入 8.首端删除元素 直接修改表头指针，使之引用当时表头结点的下一个结点。Python 系统里会自动回收无用对象的存储块，下同 9.尾端删除元素 找到倒数第二个结点，将其链接域设置为空链接 10.定位删除元素 找到要删除元素所在结点的前一结点，修改它的链接域将要求删除的结点从表中去掉 代码实现：单链表# 单向链表 class SinglyLinkedList(object): def __init__(self): self.head = None # 判空只需要判断指向的下一个节点是否为None def is_empty(self): return self.head is None # 链表首端加入新元素 def prepend(self, element): self.head = Node(element, self.head) # 尾端加入新元素 def append(self, element): # 判断是否为空链表, 是就直接添加 if self.head is None: self.head = Node(element, None) return # 链表不为空, 遍历得到表里最后一个节点, 然后用这个节点的next域记录新结点的链接 p = self.head while p.next is not None: p = p.next p.next = Node(element, None) # 首端弹出元素 def pop(self): if self.head is None: raise ValueError value = self.head.val self.head = self.head.next return value # 弹出尾端元素 def pop_last(self): # 首先判断是否为空链表 if self.head is None: raise ValueError p = self.head # 如果链表只有一个元素 if p.next is None: value = p.val self.head = None return value # 遍历链表 直到找到最后一个节点, 将前一个节点的next置为None while p.next.next is not None: p = p.next value = p.next.val p.next = None return value # 查找元素 def find(self, element): p = self.head while p is not None: if element == p.val: return p.next.val p = p.next return None # 打印出所有元素 def print_all(self): p = self.head while p is not None: print(p.val, end=&quot;&quot;) p = p.next print(&quot;&quot;) 带有尾结点的单链表# 带尾结点引用的单链表 尾结点引用---&gt;即指向最后一个节点 # 较之上一个实现, 有效的解决了尾端插入的效率问题 class SinglyLinkedListWithRearReference(SinglyLinkedList): def __init__(self): SinglyLinkedList.__init__(self) self.rear = None # 首端加入新元素 def prepend(self, element): # 如果为空列表, 就将将元素置为第一个,并将尾节点引用指向当前节点 self.head = Node(element, self.head) if self.rear is None: self.rear = self.head # 尾端加入新元素 def append(self, element): if self.head is None: # 直接调用首端加入, 对于第一个元素, 加入都是一致的 self.prepend(element) else: # 尾端加入新的元素时, 将尾结点引用指向当前新加入的节点 self.rear.next = Node(element, None) self.rear = self.rear.next # 从首端删除元素 def pop(self): if self.head is None: raise ValueError value = self.head.val # 如果尾结点引用指向了头结点, 那么说明 当前链表只有一个元素节点, 删除之后需要将尾结点引用置为None if self.rear is self.head: self.rear = None # 将链表的头指向下一个元素节点 self.head = self.head.next return value # 从尾端删除元素 def pop_last(self): if self.head is None: raise ValueError val = self.rear.val p = self.head while p.next.val != val: p = p.next p.next = None self.rear = p 循环单链表# 循环单链表 不必要使用单链表为基类 class CircularSinglyLinkedList(object): def __init__(self): self.rear = None # 判断是否为空 def is_empty(self): return self.rear is None # 首端加入新元素 def prepend(self, element): p = Node(element, None) # 如果是空链表，就要建立初始的循环链接， 即自己链接自己 if self.rear is None: p.next = p self.rear = p # 链表不空，就要链接在尾结点之后， 就是首结点 else: p.next = self.rear.next # 先将原来的首结点链接在自己的后边 self.rear.next = p # 自己成为首结点 # 尾端加入新元素 def append(self, element): # 直接调用之前的加入操作 self.prepend(element) # 将尾节点置换为新加入的结点 self.rear = self.rear.next # 删除首端元素 def pop(self): # 首先判断是否为空列表 if self.rear is None: raise ValueError p = self.rear.next # 如果尾节点指向自己，说明只有一个结点， 弹出结点之后 将尾节点置空 if self.rear is p: self.rear = None # 正常情况下，删除首结点，并将首结点置为原来首结点的下一个 else: self.rear.next = p.next return p.val # 删除尾端元素 def pop_last(self): # 首先判断是否为空列表 if self.rear is None: raise ValueError p = self.rear.next if p is self.rear: self.rear = None return p.val while p.next is not self.rear: p = p.next p.next = self.rear.next self.rear = p return p.val # 遍历所有结点 def print_all(self): p = self.rear.next while True: print(p.val, end=&quot;&quot;) if p is self.rear: print(&quot;&quot;) break p = p.next 对于单链表的一些操作：from data_structure.link_list.singly_linked_list import SinglyLinkedList # 反序链表 def reverse_by_singly(my_list): &quot;&quot;&quot; 使用修改链接关系： 1如果一直向首端添加结点，最先进去的就会在尾结点 2一直从首端取元素，最后得到的时尾结点。 这样就可以实现反转算法了 :param my_list: 被操作的链表 :return: 无 &quot;&quot;&quot; p = None while my_list.head is not None: q = my_list.head my_list.head = q.next q.next = p p = q my_list.head = p # 基于移动元素的单链表排序 def sort_linked_list_by_move_value(my_list): &quot;&quot;&quot; 为了有效实现，算法只能从头到尾方向检查和处理。 每次拿出一个元素，在已排序的序列中找到正确位置插入 :param my_list: 被操作的链表 :return: 无 &quot;&quot;&quot; if my_list.head is None: return crt = my_list.head.next # 计算从首结点之后开始，即首结点已排序完毕 while crt is not None: x = crt.val p = my_list.head # 从原链表的首结点开始进行比较，存在如下情况 # 1. 当前结点的值大于已排序完毕的结点，跳过 while p is not crt and p.val &lt;= x: p = p.next # 2. 当前结点的值小于已排序完毕的结点， 交换元素位置 while p is not crt: x, p.val = p.val, x p = p.next crt.val = x crt = crt.next # 基于调整链接关系实现排序工作 def sort_linked_list_by_change_relation(my_list): &quot;&quot;&quot; 基本处理模式与移动元素类似. 但是这里不在结点之间移动表元素，而是把被处理的结点取下来接到正确的位置上。 :param my_list: 被操作的链表 :return: 无 &quot;&quot;&quot; # 判断链表是否为空 if my_list.head is None: return # 初始 已排序的段只有一个结点 last = my_list.head # 表示已排序段的尾结点 crt = last.next # 待排序段的首结点 # 顺序链表的结点，每次处理一个结点 while crt is not None: # 设置扫描指针的初始值 p = my_list.head # 已排序，并且比较完毕的段 q = None # 已排序但为比较完毕的段 while p is not crt and p.val &lt;= crt.val: # 顺序更新两个扫描指针 q = p p = p.next # 当 p 是 crt 时 不需要修改链接，设置last到下一个结点crt if p is crt: last = crt else: # 取出当前结点 last.next = crt.next # 接好后置链接 crt.next = p if q is None: # 作为新的首结点 my_list.head = crt else: # 接在表中间 q.next = crt # crt 指向last的下一个结点 crt = last.next 经典的Josephus问题(使用循环单链表解决)：&quot;&quot;&quot; @description: 经典问题 Josephus问题 @author: merleLK @contact: merle.liukun@gmail.com @date: 17-8-2 @detail: 问题描述： 设有n个人围坐一圈，现在从第k个人开始报数，报到第m的人退出。 然后继续报数，直至所有人退出。输出出列人顺序编号。 &quot;&quot;&quot; from data_structure.link_list.singly_linked_list import CircularSinglyLinkedList # 基于list和固定大小的数组 def josephus_list(n, k, m): &quot;&quot;&quot; 1.建立一个包含n个人（编号）的list 2.找到k个人， 从那里开始 处理过程中，把对应的表元素修改为0表示人已经退出 3.反复操作： 数m个（在席）人 把表示第m个人的元素修改为0 Tips: 数到list最后元素之后转到下标为0的元素继续 :param n: 列表的长度 :param k: 开始位置 :param m: 退出条件 :return: 无 &quot;&quot;&quot; people = list(range(1, n + 1)) print(people) i = k - 1 # 开始位置的下标 for num in range(n): count = 0 # 报数编号 # 一次循环最多到m， 此时就会把最后一个人踢出 while count &lt; m: if people[i] &gt; 0: count += 1 if count == m: print(people[i], end=&quot;&quot;) people[i] = 0 i = (i + 1) % n # 遍历到最后一个位置就会从首位再次开始 print(&quot;,&quot; if num &lt; n - 1 else &quot;\n&quot;, end=&quot;&quot;) def josephus_list_pop(n, k, m): &quot;&quot;&quot; 1.算出应该退出的元素之后, 将其从表中删除 2.直至表长度为0的时候结束 复杂度： O(n^2) :param n: 列表的长度 :param k: 开始位置 :param m: 退出条件 :return: 无 &quot;&quot;&quot; people = list(range(1, n + 1)) i = k - 1 for num in range(n, 0, -1): i = (i + int(m) - 1) % num print(people.pop(i), end=&quot;&quot;) print(&quot;,&quot; if num &gt; 1 else &quot;\n&quot;, end=&quot;&quot;) class JosephusLinkedList(CircularSinglyLinkedList): &quot;&quot;&quot; 1.从形式看，循环单链表很好地表现了围坐一圈的人 2.顺序的数人头，很好的符合了循环表中沿着next链扫描 3.某人退出之后，删除相应结点，之后可以继续沿着原来的方向数人头 算法复杂度 O(m*n) &quot;&quot;&quot; def __init__(self, n, k, m): CircularSinglyLinkedList.__init__(self) # 创建包含n个元素的循环链表 for i in range(n): self.append(i + 1) # 将初始结点移动到k处 self.turn(k - 1) # 循环弹出第m个元素直到链表为空 while not self.is_empty(): self.turn(m - 1) print(self.pop(), end=&quot;&quot;) print(&quot;,&quot; if self.rear is not None else &quot;\n&quot;, end=&quot;&quot;) # 将循环表对象的rear指针沿着next移动了m步 def turn(self, m): for i in range(m): self.rear = self.rear.next if __name__ == &apos;__main__&apos;: josephus_list(10, 2, 7) josephus_list_pop(10, 2, 7) JosephusLinkedList(10, 2, 7) 源代码已经放置于我的github.]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python函数之format]]></title>
    <url>%2F2017%2F07%2F28%2Fpython%E5%87%BD%E6%95%B0%E4%B9%8Bformat%2F</url>
    <content type="text"><![CDATA[python format 函数总结文章基于Python2.7.12进行讲述： &#160;&#160;&#160;&#160;在python中格式化字符串进行输出时，通常会用到format函数。 &#160;&#160;&#160;&#160;介绍一下简单用法： &#160;&#160;&#160;&#160;1.将字符串替换 In [1]: print &apos;{0} {1} {2}&apos;.format(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;) a b c &#160;&#160;&#160;&#160;2.按照参数格式化 In [2]: print &apos;{name} {age}&apos;.format(age=21, name=&apos;lkhardy&apos;) lkhardy 21 &#160;&#160;&#160;&#160;3.限制字符串内的信息范围 In [3]: print &apos;{array[5]}&apos;.format(array=range(10)) 5 In [4]: print &apos;{array[12]}&apos;.format(array=range(10)) -------------------------------------IndexError Traceback (most recent call last) &lt;ipython-input-13-e9cd5827deae&gt; in &lt;module&gt;()----&gt; 1 print &apos;{array[12]}&apos;.format(array=range(10)) IndexError: list index out of range &#160;&#160;&#160;&#160;4.直接调用系统函数 In [14]: print &apos;{attr.__class__}&apos;.format(attr=0) &lt;type &apos;int&apos;&gt; In [15]: print &apos;{attr.__class__}&apos;.format(attr=&quot;d&quot;) &lt;type &apos;str&apos;&gt; &#160;&#160;&#160;&#160;5.转义 In [18]: print &apos;{name!r}&apos;.format(name=u&apos;汉字&apos;) u&apos;\u6c49\u5b57&apos; In [19]: print &apos;{name!r}&apos;.format(name=u&apos;lkhardy&apos;) u&apos;lkhardy&apos; In [20]: print &apos;{name!r}&apos;.format(name=u&apos;1234&apos;) u&apos;1234&apos; &#160;&#160;&#160;&#160;6.识别格式化 In [24]: print &apos;{digit:*^ 10.5f}&apos;.format(digit=1.0/3) * 0.33333* In [25]: print &apos;{digit:*^ 10.5f}&apos;.format(digit=10.0/3) * 3.33333* 未完待续。。。。。。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python的虚拟环境]]></title>
    <url>%2F2017%2F07%2F28%2FPython%E7%9A%84%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[简述：&#160;&#160;&#160;&#160;问题：&#160;&#160;&#160;&#160;我们知道Python的魅力更在于它庞大的第三方库。所以在实际的开发环境中，可能会同时进行多个项目，也许就会出现一个项目是基于python2.x，而另一个项目是基于python3.x的尴尬情况，以及其他很多不方便的情况，比如无法自动生成requirements文件etc。。。。。&#160;&#160;&#160;&#160;Methods：&#160;&#160;&#160;&#160;于是就有virtualenv这个插件很好的解决了这个问题。下面讲解它的基础使用。以及更为方便的一个插件virtualenvwrapper。 使用virtualenv&#160;&#160;&#160;&#160;安装&#160;&#160;&#160;&#160;virtualenv的安装十分简单，使用pip就能很方便的安装： sudo pip install virtualenv &#160;&#160;&#160;&#160;基础操作&#160;&#160;&#160;&#160;1.创建虚拟环境&#160;&#160;&#160;&#160;使用如下命令即可在当前目录下创建一个名为env1的虚拟环境 virtualenv env1 &#160;&#160;&#160;&#160;还可以创建指定解释器版本的虚拟环境 virtualenv -p python2.7 env2.7 #该环境下解释器为python2.7virtualenv -p python3.5 env3.5 #该环境下解释器为python3.5 &#160;&#160;&#160;&#160;如果你的系统里的python已经安装第三方库，你想直接继承过来使用，使用如下命令 virtualenv –system-site-packages env &#160;&#160;&#160;&#160;默认的是不加继承的，或者使用以下命令 virtualenv –no-site-packages env &#160;&#160;&#160;&#160;2.启动和退出虚拟环境&#160;&#160;&#160;&#160;启动，要想启动创建好的虚拟环境，需要到其安装目录(即当前目录下)，输入如下命令： source env1/bin/activate 当命令行头出现(env1)时就表示虚拟环境已经启动。此时我们再次使用pip、setools、easy_install等安装的插件就只会在此虚拟环境之下，不会影响系统内的默认环境、或者其他的虚拟环境。 &#160;&#160;&#160;&#160;退出，要想从当前虚拟环境之下退出，只需执行如下命令即可： deactivate 使用virtualenvwrapper&#160;&#160;&#160;&#160;virtualenv的出现使得项目间的环境使用更加方便和简洁，而virtualenvwrapper是一个基于virtualenv之上的一个工具，它提供了更加方便的虚拟环境管理方式。即统一管理。 &#160;&#160;&#160;&#160;安装 &#160;&#160;&#160;&#160;安装操作仍然十分简单，使用如下命令即可安装此工具： sudo pip install virtualenvwrapper &#160;&#160;&#160;&#160;windows下安装 pip install virtualenvwrapper-win &#160;&#160;&#160;&#160;virtualenvwrapper默认将所有的虚拟环境放在~/.virtualenvs目录下管理，但是也可以修改环境变量WORKON_HOME来指定虚拟环境的保存目录。 &#160;&#160;&#160;&#160;基本操作&#160;&#160;&#160;&#160;1.启动&#160;&#160;&#160;&#160;使用前需要在shell里执行： source /usr/local/bin/virtualenvwrapper.sh 为了方便使用这个命令，我们可以把如下命令加到shell的配置文件中： sudo vim ~/.profile export WORKON_HOME=$HOME/.virtualenvsexport PROJECT_HOME=$HOME/Develsource /usr/local/bin/virtualenvwrapper.sh &#160;&#160;&#160;&#160;2.相关命令&#160;&#160;&#160;&#160;列出已有的虚拟环境，命令如下： workon &#160;&#160;&#160;&#160;创建新的虚拟环境，创建完毕之后会自动切换到当前环境，命令如下： mkvirtualenv env1 &#160;&#160;&#160;&#160;列出当前环境下中所安装的包，命令如下： lssitepackages &#160;&#160;&#160;&#160;切换虚拟环境，命令如下： workon env2 &#160;&#160;&#160;&#160;退出当前环境，命令如下： deactivate &#160;&#160;&#160;&#160;删除虚拟环境，如果该环境正在使用，那么必须先退出该环境，命令如下： rmvirtualenv env1 &#160;&#160;&#160;&#160;显示指定环境的详情，命令如下： showvirtualenv env1 &#160;&#160;&#160;&#160;把指定的目录加入当前使用的环境path中，命令如下： add2virtualenv dir dir &#160;&#160;&#160;&#160;复制一份虚拟环境 cpvirtualenv source dest &#160;&#160;&#160;&#160;还可以在上面我们配置过的目录PROJECT_HOME下创建一个新项目。 mkproject project_name OK，以上就是关于virtualenv和增强工具virtualenvwrapper的简单使用介绍。另外说一点，在windows上使用时会出现一些命令使用的问题，好好搜索哦，本文是基于linux上使用的….呼呼，欢迎大家指正哦。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新博客搬迁计划]]></title>
    <url>%2F2017%2F07%2F27%2F%E6%96%B0%E5%8D%9A%E5%AE%A2%E6%90%AC%E8%BF%81%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[懒人自述很久之前用wordpress搭建一个个人博客。但是后来服务器到期了，决定搬迁一下。 新博客采用hexo搭建,主题使用next。简直完美。 正好趁此机会把之前写的博客好好整理一番。熟悉熟悉自己的技能栈。 开始找工作啦。。。。。。]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>杂项</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js遍历对象的几个方法]]></title>
    <url>%2F2017%2F07%2F26%2Fjs%E9%81%8D%E5%8E%86%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E4%B8%AA%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[有关对象遍历的几个方法。所有继承到Object的对象都会继承到hasOwnProerty()方法，此方法用来检测一个对象是否包含特定的自身属性，其与in运算符不同之处在于，hasOwnProperty方法会忽略掉那些从原型链上继承到的属性。 1.一个简单的例子： 检测对象obj是否含有自身属性’prop’. obj = new Object(); obj.prop = &apos;exists&apos;; function changeO(){ // 将prop属性删除。 obj.newprop = obj.prop; delete obj.prop; } alert(obj.hasOwnProperty(&apos;prop&apos;)); // True changeO(); alert(obj.hasOwnProperty(&apos;prop&apos;)); // False 对于从原型链上继承的属性，hasOwnProperty方法会将其忽略。而in操作符则是将原型链上的属性也涵盖。 alert(obj.hasOwnProperty(&apos;toString&apos;)); // False alert(&apos;toString&apos; in obj); // True 2.遍历一个对象所有的自身属性。忽略掉继承属性。 var buz = { fog: &apos;stack&apos;, name: &apos;hello&apos; }; for (var name in buz) { if (buz.hasOwnProperty(name)) { alert(&quot;this is fog (&quot; + name + &quot;) for sure. Value: &quot; + buz[name]); } else { alert(name); // toString or something else } } 注意： 此例子中for...in循环只会遍历可枚举的属性。 3.处理json对象转为字符串。 我们需要遍历一个json对象。 var s = &apos;{&quot;data&quot;:[{&quot;d1&quot;: &quot;c1&quot;, &quot;d2&quot;: &quot;c2&quot;}]}&apos;; var parsedData = JSON.parse(s); for(var i in parserd_data){ for(var j in parserd_data[i]){ alert(parserd_data[i][j]); console.log(parserd_data[i][j]); for (var k in parserd_data[i][j]){ alert(parserd_data[i][j][k]); } } } 这种方法有些费劲，所以可以定义一个函数进行遍历,虽然函数很长，但是对基本的情况也进行了校验，没有使用那么多的嵌套循环。 function JsonToStr(data){ var resultStr = &quot;&quot;; for (var i in data){ if (data.hasOwnProperty(i)){ if (typeof(data[i]) === &quot;object&quot;){ JsonToStr(data[i]); } else{ if(resultStr === &quot;&quot;){ resultStr = i + &quot;,&quot; + data[i]; } else{ resultStr = resultStr + &quot;,&quot; + i + &quot;,&quot; + data[i]; } } } } return resultStr; } 参考资料： MDN web docs]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScrip基本数据类型的常用操作]]></title>
    <url>%2F2017%2F07%2F25%2FJavaScrip%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[一、背景在日常项目中，发现会经常用到JS基本数据类型相关的一些操作。经常是当场搜索相关的用法。还是不利于自己学习。所以还是记录以下，增加自己的记忆。 二、字符串相关1.移除字符串中某些特定的字符。 1.1使用replace()函数替换 # 去除myStr字符串中的, : ; = &apos;[ ] &apos; + 等符号 var myStr = &quot;123,abc:456;abc=abc[]&quot;; myStr.replace(/[,:;=\[\]]+/g,&apos;&apos;); output: &quot;123abc456abcabc&quot; 1.2使用split()和join()函数 # 去掉冒号: var myString = &quot;12:30:21&quot; var handledString = myString.split(&quot;:&quot;).join(&quot;&quot;) output: &quot;123021&quot; # 去除myStr字符串中的, : ; = &apos;[ ] &apos; + 等符号 var myStr = &quot;123,abc:456;abc=abc[]&quot;; var handledString = my_str.split(/[,:;]/).join(&quot;&quot;) output: &quot;123abc456abc=abc[]&quot; 两中方法都使用了正则表达式进行处理。 2.删除字符串最后一个字符。 2.1使用substring()函数 # 去除字符串中最后一个, var myString = &quot;1,2,3,4,&quot; var handledString = myString.substring(0, s.length-1) output: &quot;1,2,3,4&quot; substring(start, end)函数，经常用于提取一个字符串中下标在[start, end)之间的子字符串。包含start,不包含end。 如果 start 与 end 相等，那么该方法返回的就是一个空串（即长度为 0 的字符串）。 如果 start 比 end 大，那么该方法在提取子串之前会先交换这两个参数。 如果 start 或 end 为负数，那么它将被替换为 0。 3.获取字符串中子字符串。 3.1 使用2.1中的substring()函数，但需要指定下标。 3.2使用substr()函数 var myString = &quot;0123456789&quot; # 获取从第6位开始的所有剩余字符, 下标从0开始 var handledString = myString.substr(5) substr(start, length)函数，用于返回一个从指定位置开始的指定长度的子字符串。 参数说明 start 必须要有，所需字符串的起始位置。 length 可选，返回的字符串中应包含字符的个数 如果start为负数，那么start=str.length+start 如果length为0或者负数，就会返回一个空字符串 如果不指定length参数，则字符串就会一直到str的末尾 4.判断字符串是否在另一个字符串中。 4.1使用indexof()函数 var fullStr = &apos;helloWorld&apos;; if(fulleStr.indexof(&apos;hello&apos;)){ alert(&apos;fullStr has str hello&apos;); } fullStr.indexof(str)函数,用于返回String对象内第一次出现子字符串的字符位置。如果没有找到子字符串就会返回-1 未完待续……………..]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[from-import和import]]></title>
    <url>%2F2017%2F07%2F24%2Ffrom-import%E5%92%8Cimport%2F</url>
    <content type="text"><![CDATA[简介：在使用Python编写项目时，我们经常使用import xx或者from xx import a去导入其他模块或者其他模块中的一些对象和方法，那么这两个语句有什么不一样的呢。在此处，做一下总结，让自己对它们的原理进行一些了解。 方法：Python提供了三种方法引入外部模块，import语句、from...import...和__import__函数。我们最为常用的是前两者。对于第三种方式，它与import语句类似，只是前者显式的将模块的名称作为字符串传递并赋值给命名空间的变量。 注意事项： 尽量优先使用import语句，如import a.B，可以访问B 有节制的使用from a import B形式，但是这样也可以直接访问B 避免使用from a import *形式，这样会污染命名空间，并且导入了哪些模块也不清晰。 import的原理Python的import机制，在Python初始化运行环境时候会预先加载一批内建模块到内存中，这些模块相关的信息存放在了sys.modules中，用户导入sys模块后使用sys.modules.items()可以显示所有预加载模块的相关信息。 当加载一个模块时，Python解释器做了以下一些事情： 在sys.modules中进行搜索，如果该模块已经存在，就将该模块导入到当前局部命名空间。加载就结束了。 如果在sys.modules中找不到该模块的名称，则为需要导入的模块创建一个字典对象，并将该对象信息插入到sys.modules中。 加载前确认是否需要对模块对应的文件进行编译，如果需要编译就要进行编译。 执行动态加载，在当前模块中的命名空间中执行编译后的字节码文件，并将其中所有的对象放入到模块对应的字典中。 无节制使用from…import…带来的问题命名空间冲突例子：有如下三个文件 在模块a和模块b中都定义了add()函数。那么我们在test文件中使用from...import...的形式导入add时，最终起作用的是哪一个呢？ # filename a.py def add(): print(&quot;add in module A&quot;) # filename b.py def add(): print(&quot;add in module B&quot;) # filename test.py from a import add from b import add if __name__ == &apos;__main__&apos;: add() 运行test.py之后，我们得到输出： &quot;add in module B&quot; 也就是说在这里起作用的是最近导入的add(),它完全覆盖了当前命名空间中之前导入的模块a中的add().所以在大型的项目中，我们所包含的包和模块数目非常多，因此使用from...import...语句将会大大增加了命名空间冲突的概率，很大可能会导致出现无法预料的错误和问题。所有有必要有节制的使用from...import...语句。 当然在以下的一些情况中可以考虑使用from...import...语句 当只需要导入部分属性或者方法时。 模块中的某些属性和方法使用频率很高导致使用a.B这种形式进行访问过于烦琐时。 某模块的文档明确说明需要使用from...import形式，能后更为简单和便利时。如使用from io.drivers import zip要比使用import iodrivers.zip更加方便。 循环嵌套导入问题例子： # filename c1.py from c2 import g def x(): pass # filename c2.py from c1 import x def g(): pass 像上边的两个文件，无论运行哪一个，都会报出ImportError的错误。解析如下： 在执行c1.py的加载过程的时候需要创建新的模块对象c1然后执行c1.py所对应的字节码，此时遇到语句from c2 import g,而此时c2在sys.modules中并不存在。然后就会创建与c2对应的模块对象并执行c2.py， 而在执行c2.py时候，又遇到from c1 import x语句，此时的c1对象虽然已经存在，但是初始化的过程并未完成，所以不存在x对象，所以c2也无法初始化完成。 再次执行c1.py时，就会报出ImportError: cannot import name g异常。 而使用import可以解决这个问题。修改文件如下： # filename c1.py import c2 def x(): pass # filename c2.py import c1 def g(): pass 此时就可以运行这两个文件了。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[collections模块之namedtuple使用]]></title>
    <url>%2F2017%2F07%2F23%2Fcollections%E6%A8%A1%E5%9D%97%E4%B9%8Bnamedtuple%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[简介在python中tuple是一个不可变的且轻量型的集合对象，但是使用时，我们只能通过索引的方式去获取元组中的元素。不太方便，并且容易出错。而在collections模块中namedtuple对象则给出了一个更加便捷的操作方式，即给元组中的元素命名。它可以被用作类似于struct或其他常见record types，但它们是不可变的。 简单使用1.创建namedtuple form collections import namedtuple Point = namedtuple(&apos;Point&apos;, &apos;x y&apos;) point1 = Point(1.0, 5.0) point2 = Point(2.5, 1.5) 上例即创建了一个名字为Point的namedtuple对象. 2.namedtuple对象的参数解析 a.示例中的Point是namedtuple的名称。 b.示例中的x y这个字符串中的两个用空格隔开的字符表示这个namedtuple中有两个元素，名为x,y.(避免关键字) c.如果在数据库中读列名作为元素名时可能会出现相同名，程序会报错，那么可以在定义namedtuple时开启自动重命名。如下： Point = namedtuple(‘Point’, ‘x y’， rename=True) 此时命名方式为_indexnumber,下划线+索引号。 调用方式3.1索引方式调用 对于示例中的定义的Point1,可以采用索引方式调用获取其中的值. In [7]: x = point1[0] Out : 1.0 In [10]: y = point1[1] Out : 5.0 3.2元素名方式调用 对于示例中的定义的Point2,可以采用元素名调用获取其中的值. In [12]: x = point2.x Out : 2.5 In [14]: y = point2.y Out : 1.5 总结4.1 你应该使用namedtuple代替那些你认为影响了你代码的易读性的tuple，以便让你的代码更加pythonic. 4.2 此外，你还可以替换那些没有功能函数、只有字段的普通不可变类。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker简单使用]]></title>
    <url>%2F2017%2F07%2F22%2Fdocker%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[简介:Docker是一个开源的引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在笔记本上编译测试通过的容器可以批量地在生产环境中部署，包括VMs（虚拟机）、bare metal、OpenStack 集群和其他的基础应用平台。Docker通常用于如下场景： web应用的自动化打包和发布； 自动化测试和持续集成、发布； 在服务型环境中部署和调整数据库或其他的后台应用； 从头编译或者扩展现有的OpenShift或Cloud Foundry平台来搭建自己的PaaS环境 删除：1.删除container a.单独删除具体某一个容器 ➜ ~ sudo docker rm CONTAINER_ID ➜ ~ sudo docker rm -f 删除运行中的容器 b.删除当前所有容器(已终止运行) ➜ ~ sudo docker rm $(sudo docker ps -a -q) 2.删除image a.删除某个镜像 ➜ ~ sudo docker rmi &lt;image_id&gt; b.删除所有镜像 ➜ ~ sudo docker rmi $(sudo docker images -q) c.删除所有untagged的镜像(就是id为None的镜像) ➜ ~ sudo docker images | grep &quot;^&lt;none&gt;&quot; | awk &quot;{print $3}&quot; 查看：1.查看所有容器 ➜ ~ sudo docker ps -a 2.查看所有正在运行的容器 ➜ ~ sudo docker ps 3.查看镜像 ➜ ~ sudo docker images 运行：1.创建一个container ➜ ~ sudo docker run image_name 2.启动一个container ➜ ~ sudo docker run container_name 3.重命名container ➜ ~ sudo docker rename old_name new_name 4.重启某个容器 ➜ ~ sudo docker restart container_name Tips: docker run 的相关参数说明: --name 指定容器名 -p 指定端口映射 eg 3306:3306 -v 挂载数据卷或者本地目录映射 :ro 挂载为只读 -d 后台持续运行 -i 交互式操作 -t 终端 -rm 容器退出后随之将其删除(与-d 冲突) 停止：1.停止所有正在运行的容器 ➜ ~ sudo docker kill $(docker ps -q) 相关示例：1.使用docker创建postgresql数据库容器 sudo docker search postgres sudo docker pull postgres:9.5.7 使用镜像创建容器，并运行 sudo docker run --name postgres-server -p 5432:5432 -e POSTGRES_PASSWORD=111111 -d postgres:9.5.7 启动容器 sudo docker start container_id 使用镜像创建一个client sudo docker run --name postgresql-client -it --link postgres-server:postgres postgres:9.5.7 psql -U postgres 此时就可以在client中的命令行上实现操作数据库啦。 2.使用docker创建mysql数据库容器 # 查询mysql镜像 sudo docker search mysql # 拉到本机 sudo docker pull mysql # 创建一个mysql服务端,并将端口映射到本机的3306端口 sudo docker run --name mysql-server -p 3306:3306 -e MYSQL_ROOT_PASSWORD=yourpassword -d mysql # 创建一个mysql客户端，用来管理数据库 sudo docker run --name mysql-client -it --link mysql-server:mysql mysql sh -c &apos;exec mysql -h&quot;$MYSQL_PORT_3306_TCP_ADDR&quot; -P&quot;$MYSQL_PORT_3306_TCP_PORT&quot; -uroot -p&quot;$MYSQL_ENV_MYSQL_ROOT_PASSWORD&quot;&apos; # 启动容器 sudo docker start container_name 注：可以通过指定mysql数据库的外部数据卷，让数据保存在本机上，便于迁移。 -v /my/own/datadir:/var/lib/mysql 其中 ：号前面是本机的数据卷地址， 这样表示宿主机的/my/own/datadir目录挂载到容器内的/var/lib/mysql目录。 现在就可以像在本机安装mysql数据库一样的使用啦。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>docker</tag>
      </tags>
  </entry>
</search>